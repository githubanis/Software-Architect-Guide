<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Software Architect Learning Guide</title>
  <style>
    :root{
      --bg:#0b1220;        /* page background */
      --panel:#0f172a;     /* cards/nav background */
      --muted:#94a3b8;     /* secondary text */
      --text:#e6edf6;      /* primary text */
      --accent:#22d3ee;    /* cyan */
      --accent-2:#a78bfa;  /* violet */
      --ok:#22c55e; --bad:#ef4444; --warn:#eab308;
      --radius:14px;
      --mobile-padding: 0.75rem;
      --desktop-padding: 1rem;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background:linear-gradient(180deg, #0b1220 0%, #0b1220 40%, #0e1628 100%);
      color:var(--text);
      font-size: 16px;
    }
    
    /* --- Mobile First Responsive Design --- */
    /* --- Topbar --- */
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter: saturate(180%) blur(10px);
      background:rgba(15,23,42,.95);
      border-bottom:1px solid rgba(148,163,184,.15);
    }
    .topbar{
      display:flex; 
      flex-direction: column;
      gap:.5rem; 
      align-items:stretch; 
      padding:var(--mobile-padding);
    }
    .topbar-row{
      display: flex;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }
    .brand{
      font-weight:700; 
      letter-spacing:.3px;
      font-size: 1.1rem;
      flex-shrink: 0;
    }
    .search{
      flex:1; 
      min-width:0;
    }
    .search input{
      width:100%; 
      padding:.6rem .8rem; 
      border-radius:999px; 
      border:1px solid rgba(148,163,184,.25);
      background:#0b1220; 
      color:var(--text);
      font-size: 16px; /* Prevents zoom on iOS */
    }
    .filters{
      display:flex; 
      gap:.375rem; 
      align-items:center;
      flex-wrap: wrap;
      width: 100%;
      justify-content: space-between;
    }
    .mobile-menu-toggle{
      display: block;
      background: none;
      border: 1px solid rgba(148,163,184,.25);
      color: var(--text);
      padding: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2rem;
    }
    select, button, .chip{
      background:#0b1220; 
      color:var(--text); 
      border:1px solid rgba(148,163,184,.25); 
      border-radius:999px; 
      padding:.45rem .65rem;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    button{cursor:pointer}
    button:hover, .chip:hover{border-color:rgba(34,211,238,.6)}
    button:focus, select:focus, .search input:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    /* --- Topic scroller --- */
    .topic-strip{
      display:flex; 
      gap:.375rem; 
      overflow-x:auto; 
      overflow-y: hidden;
      padding:.5rem var(--mobile-padding) .75rem; 
      scroll-snap-type:x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .topic-strip::-webkit-scrollbar{height:6px}
    .topic-strip::-webkit-scrollbar-thumb{background:rgba(148,163,184,.4); border-radius:999px}
    .topic-strip::-webkit-scrollbar-track{background:rgba(148,163,184,.1)}
    .topic-btn{
      scroll-snap-align:start; 
      white-space:nowrap;
      flex-shrink: 0;
      font-size: 0.85rem;
      padding: 0.4rem 0.8rem;
    }
    .topic-btn.chip-active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }

    /* --- Mobile Layout --- */
    main{
      max-width:1200px; 
      margin:0.5rem auto; 
      padding:0 var(--mobile-padding); 
      display:block;
    }
    
    .mobile-sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 60;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    .mobile-sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    /* --- Sidebar (subtopics for current category) --- */
    .sidebar{
      background:var(--panel); 
      border:1px solid rgba(148,163,184,.15); 
      border-radius:var(--radius); 
      padding:1rem;
      margin-bottom: 1rem;
      /* Mobile: Show as collapsible section */
      position: relative;
    }
    .sidebar-mobile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 0.5rem 0;
    }
    .sidebar-mobile-toggle {
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.25rem;
      transform: rotate(0deg);
      transition: transform 0.3s ease;
    }
    .sidebar-mobile-toggle.active {
      transform: rotate(180deg);
    }
    .sidebar-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .sidebar-content.active {
      max-height: 400px;
    }
    .sidebar h3{
      margin:.25rem 0 .5rem; 
      color:var(--muted); 
      font-weight:600; 
      font-size:.9rem; 
      letter-spacing:.04em;
    }
    .sidelist{
      display:flex; 
      flex-direction:column; 
      gap:.4rem;
    }
    .sidelink{
      border-radius:10px; 
      padding:.45rem .6rem; 
      text-decoration:none; 
      color:var(--text); 
      border:1px solid transparent;
      display: block;
    }
    .sidelink:hover{background:#0b1220; border-color:rgba(148,163,184,.25)}
    .sidelink.active{background:linear-gradient(90deg, rgba(34,211,238,.13), rgba(167,139,250,.13)); border-color:rgba(34,211,238,.5)}

    /* --- Content cards --- */
    .card{
      background:var(--panel); 
      border:1px solid rgba(148,163,184,.15); 
      border-radius:var(--radius); 
      padding:1rem;
      margin-bottom: 1rem;
    }
    .title{
      display:flex; 
      align-items:flex-start; 
      gap:.6rem;
      flex-wrap: wrap;
    }
    .title .tag{
      font-size:.75rem; 
      color:var(--muted); 
      border:1px dashed rgba(148,163,184,.35); 
      padding:.15rem .5rem; 
      border-radius:999px;
      flex-shrink: 0;
    }
    h1 { font-size: 1.8rem; margin: 0.5rem 0; }
    h2 { font-size: 1.5rem; margin:.4rem 0 .8rem; line-height: 1.3; }
    h3 { font-size: 1.3rem; margin: 1rem 0 0.5rem; }
    h4 { font-size: 1.1rem; margin:1rem 0 .5rem; font-weight: 600; }
    p{line-height:1.6; margin: 0.75rem 0;}
    ul, ol{line-height:1.6; margin:.5rem 0 1rem; padding-left: 1.25rem;}
    li { margin: 0.25rem 0; }
    .grid{
      display:grid; 
      gap:1rem; 
      grid-template-columns:1fr;
      margin: 1rem 0;
    }
    .note{font-size:.9rem; color:var(--muted); margin: 0.75rem 0; padding: 0.75rem; background: rgba(148,163,184,0.05); border-radius: 8px; border-left: 3px solid var(--muted);}
    .good{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}

    /* --- Code blocks --- */
    pre{
      position:relative; 
      background:#0b1220; 
      border:1px solid rgba(148,163,184,.2); 
      color:#e6edf6; 
      border-radius:12px; 
      padding:0.75rem; 
      margin: 1rem 0;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
    }
    code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; 
      font-size:.85rem;
      line-height: 1.4;
    }
    .copy{
      position:absolute; 
      top:.5rem; 
      right:.5rem; 
      border-radius:8px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      z-index: 10;
    }
    
    /* Inline code */
    p code, li code {
      background: rgba(148,163,184,.15);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-size: 0.9em;
    }

    /* --- Utilities --- */
    .hidden{display:none}
    .muted{color:var(--muted)}
    .actions{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; margin:.75rem 0}
    .pill{background:transparent; border:1px solid rgba(148,163,184,.3); padding:.3rem .6rem; border-radius:999px; font-size:.8rem}
    .kbd{display:inline-block; border:1px solid rgba(148,163,184,.35); border-bottom-width:2px; border-radius:6px; padding:.15rem .4rem; font-size:.8rem; background:#0b1220}
    .footer{color:var(--muted); text-align:center; padding:2rem 1rem 3rem}
    a{color:var(--accent); text-decoration: none;}
    a:hover { text-decoration: underline; }
    .category-label{font-size:.75rem; color:var(--muted)}
    
    /* --- Tablet Styles --- */
    @media (min-width: 768px) {
      body { font-size: 17px; }
      .topbar {
        flex-direction: row;
        align-items: center;
        padding: var(--desktop-padding);
        gap: 1rem;
      }
      .topbar-row {
        display: contents;
      }
      .mobile-menu-toggle { display: none; }
      .filters {
        width: auto;
        justify-content: flex-end;
      }
      .grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .card {
        padding: 1.2rem;
      }
      .topic-strip {
        padding: 0.75rem var(--desktop-padding) 1rem;
      }
      main {
        margin: 1rem auto;
        padding: 0 var(--desktop-padding);
      }
    }
    
    /* --- Desktop Styles --- */
    @media (min-width: 980px) {
      main {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 1.5rem;
        align-items: start;
      }
      .sidebar {
        position: sticky;
        top: 120px;
        height: fit-content;
        margin-bottom: 0;
      }
      .sidebar-mobile-header { display: none; }
      .sidebar-content {
        max-height: none;
        overflow: visible;
      }
      .sidelist {
        max-height: 70vh;
        overflow-y: auto;
      }
    }
    
    /* --- Print Styles --- */
    @media print {
      header { display: none; }
      .sidebar { display: none; }
      main { 
        display: block; 
        max-width: none; 
        margin: 0; 
        padding: 0;
      }
      .card {
        break-inside: avoid;
        margin-bottom: 2rem;
      }
      pre {
        break-inside: avoid;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="topbar-row">
        <div class="brand">🧭 Software Architect Guide</div>
        <div class="search"><input id="search" placeholder="Search topics..." /></div>
        <button class="mobile-menu-toggle" id="mobileMenuToggle" title="Toggle filters">⚙️</button>
      </div>
      <div class="filters" id="filtersMenu">
        <select id="categoryFilter" title="Filter by category"></select>
        <button id="printBtn" title="Print current topic">🖨️</button>
        <button id="expandAllBtn" title="Show all topics">📚</button>
        <button id="collapseAllBtn" title="Show only selected">🗂️</button>
      </div>
    </div>
    <div class="topic-strip" id="topicStrip" aria-label="All topics"></div>
  </header>

  <div class="mobile-sidebar-overlay" id="mobileOverlay"></div>
  <main>
    <aside class="sidebar">
      <div class="sidebar-mobile-header">
        <h3 id="sideTitle">Subtopics</h3>
        <button class="sidebar-mobile-toggle" id="sidebarToggle">▼</button>
      </div>
      <div class="sidebar-content" id="sidebarContent">
        <div class="sidelist" id="sideList"></div>
        <div class="note" style="margin-top:.75rem">Tip: press <span class="kbd">/</span> to jump to search. Your last opened topic is remembered.</div>
      </div>
    </aside>

    <section id="contentArea">
      <!-- Sections are injected below. Each section uses data attributes for title & category. -->

      <!-- ===== Fundamentals ===== -->
      <article class="card topic" id="fundamentals" data-title="Core Software Architecture Fundamentals" data-category="Fundamentals">
        <div class="title"><span class="tag">Fundamentals</span><h2>Core Software Architecture Fundamentals</h2></div>
        <h4>Key Concept</h4>
        <p>Software architecture is the set of fundamental choices made during the development of a software system. It defines the high-level structure of the system, the discipline of its creation, and the evolution of its components. The goal is to design a system that is not only <em>correct</em> and <em>functional</em>, but also <em>evolvable</em>, <em>maintainable</em>, and <em>valuable</em> to the business over the long term.</p>

        <h4>Core Learning</h4>
        <p>The most important takeaway is that architecture is a game of <strong>trade-offs</strong>. There is no single "best" architecture. A good architect understands the business goals and constraints, identifies the critical quality attributes (non-functional requirements), and makes deliberate, documented decisions to optimize for them. This involves balancing competing concerns like performance vs. cost, or security vs. development speed.</p>

        <div class="grid">
          <div>
            <h4>Key Pillars</h4>
            <ul>
              <li><strong>Model the Domain:</strong> Before writing code, understand the business domain and model its entities and processes. This is a cornerstone of <a href="#" onclick="showTopic('ddd', true); return false;">Domain-Driven Design (DDD)</a>.</li>
              <li><strong>Define Quality Attributes (NFRs):</strong> Explicitly define and prioritize non-functional requirements like performance, security, and reliability. See <a href="#" onclick="showTopic('nfrs', true); return false;">NFRs</a>.</li>
              <li><strong>Make Trade-offs Explicit:</strong> Use tools like <a href="#" onclick="showTopic('adr', true); return false;">Architecture Decision Records (ADRs)</a> to document significant decisions and their rationale.</li>
              <li><strong>Use Bounded Contexts:</strong> Break down complex systems into manageable, independent parts, each with its own domain model. This is a core concept from DDD.</li>
              <li><strong>Automate Everything:</strong> A mature architecture relies on robust automation for building, testing, deploying, and monitoring the system. See <a href="#" onclick="showTopic('cicd', true); return false;">CI/CD</a> and <a href="#" onclick="showTopic('observability', true); return false;">Observability</a>.</li>
            </ul>
          </div>
          <div>
            <h4>Checklist for a Sound Architecture</h4>
            <ul>
              <li><strong>Clear Ownership:</strong> Is there a clear owner for every component, service, or module?</li>
              <li><strong>Stable Interfaces:</strong> Are the contracts between components well-defined and stable, allowing implementations to change without breaking clients?</li>
              <li><strong>Data Lifecycle Management:</strong> Is the flow and lifecycle of data (create, read, update, delete, archive) clearly understood and documented?</li>
              <li><strong>Security by Design:</strong> Is security a foundational part of the design (e.g., least privilege, encryption by default), not an afterthought? See <a href="#" onclick="showTopic('secure-design', true); return false;">Secure Design</a>.</li>
              <li><strong>Failure Planning:</strong> Have potential failure modes been identified, and is the system designed to be resilient? Are there plans for disaster recovery and chaos engineering drills? See <a href="#" onclick="showTopic('ha-dr', true); return false;">High Availability & DR</a>.</li>
            </ul>
          </div>
        </div>
      </article>

      <article class="card topic" id="design-principles" data-title="Software Design Principles" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>Software Design Principles</h2></div>
        <h4>Key Concept</h4>
        <p>Software design principles are guidelines and heuristics for creating high-quality, maintainable, and understandable software. Unlike architectural styles, which define the overall structure, design principles operate at a lower level, guiding the design of classes, modules, and functions. They help manage complexity and reduce the cost of change over time.</p>

        <h4>Core Learning</h4>
        <p>The core idea is to write code that is easy to change. This is achieved by promoting loose coupling, high cohesion, and clear separation of concerns. Applying these principles pragmatically is key; they are not rigid laws. Always prefer a design that is clear and simple over one that is overly engineered and clever. The goal is to solve the problem at hand while keeping the door open for future evolution.</p>

        <h4>Key Principles Explained</h4>
        <ul>
          <li><strong><a href="#" onclick="showTopic('solid', true); return false;">SOLID</a></strong>: A collection of five object-oriented design principles that are fundamental to building robust and maintainable systems. They are Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.</li>
          <li><strong><a href="#" onclick="showTopic('dry', true); return false;">DRY (Don’t Repeat Yourself)</a></strong>: Aims to have a single, authoritative source of truth for every piece of knowledge or logic in the system.</li>
          <li><strong><a href="#" onclick="showTopic('kiss', true); return false;">KISS (Keep It Simple, Stupid)</a></strong>: Advocates for keeping solutions as simple as possible. Avoid accidental complexity and choose the most straightforward approach that works.</li>
          <li><strong><a href="#" onclick="showTopic('yagni', true); return false;">YAGNI (You Aren’t Gonna Need It)</a></strong>: A principle of extreme programming that states you should not add functionality until it is deemed necessary. Avoid speculative features.</li>
          <li><strong><a href="#" onclick="showTopic('soc', true); return false;">Separation of Concerns (SoC)</a></strong>: Dictates that a system should be partitioned into distinct parts (concerns) with minimal overlap in functionality. For example, separating UI, business logic, and data access.</li>
          <li><strong><a href="#" onclick="showTopic('di', true); return false;">Dependency Inversion Principle (DIP)</a></strong>: A key part of SOLID, this principle states that high-level modules should not depend on low-level modules; both should depend on abstractions. This decouples the code and makes it more flexible.</li>
        </ul>
      </article>

      <!-- ===== DRY / KISS / YAGNI / SoC / DI ===== -->
      <article class="card topic" id="dry" data-title="DRY (Don’t Repeat Yourself)" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>DRY (Don’t Repeat Yourself)</h2></div>
        
        <h4>Key Concept</h4>
        <p>The DRY principle states that "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." It's about avoiding redundancy in your codebase to improve maintainability, reduce bugs, and increase clarity. This applies not just to code, but also to documentation, database schemas, and build scripts.</p>

        <h4>Core Learning</h4>
        <p>The goal of DRY is to centralize logic and data so that any modification only needs to happen in one place. When you have duplicate code, a change in requirements means you have to find and update every single instance, which is error-prone. A single source of truth is easier to manage and reason about.</p>
        
        <h4>Basics with Example</h4>
        <p>Imagine you have a web application where the same validation logic for an email address is written in JavaScript on the client-side and in C# on the server-side. If the validation rules change (e.g., to allow a new top-level domain), you have to update it in both places. A better, DRY-er approach is to have a shared library or a single source of truth for this logic.</p>
        <p>The provided C# example is a good illustration within a single class:</p>
        <pre><button class="copy">Copy</button><code>public class InvoiceService {
  // The authoritative representation of the tax rate.
  // If the tax rate changes, you only need to update this one line.
  private const decimal TaxRate = 0.15m; 

  // This function reuses the TaxRate constant.
  public decimal CalculateTax(decimal amount) {
    return amount * TaxRate;
  }

  // This function reuses the CalculateTax method, avoiding repeated logic.
  public decimal CalculateFinal(decimal amount) {
    return amount + CalculateTax(amount);
  }
}</code></pre>
        
        <h4>Flow of Thought for Applying DRY</h4>
        <ol>
          <li><strong>Identify Repetition:</strong> Look for identical or very similar blocks of code, magic strings/numbers, or configuration values across the application.</li>
          <li><strong>Abstract the Knowledge:</strong> Create a single, authoritative source for that piece of knowledge. This could be a function, a constant, a configuration file, or a shared library.</li>
          <li><strong>Replace Duplicates:</strong> Replace all instances of the repeated knowledge with a reference to the new, single source.</li>
        </ol>

        <h4>Watch-outs</h4>
        <ul>
          <li class="warn"><strong>False DRY (Accidental Duplication):</strong> Be careful not to abstract things that look similar but represent different concepts. Forcing them into a single abstraction can lead to complex, coupled code that is hard to change. This is a common pitfall and is often worse than the initial duplication. For instance, a validation rule that a product name and a customer name must both be 50 characters long might be a coincidence, not a shared business rule.</li>
          <li>This principle is closely related to <a href="#" onclick="showTopic('soc', true); return false;">Separation of Concerns</a>, as both aim to create more modular and maintainable code.</li>
        </ul>
      </article>

      <article class="card topic" id="kiss" data-title="KISS (Keep It Simple, Stupid)" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>KISS (Keep It Simple)</h2></div>
        <h4>Key Concept</h4>
        <p>KISS is a design principle that states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. It's about choosing the most straightforward solution that effectively solves the problem.</p>

        <h4>Core Learning</h4>
        <p>Complexity is the enemy of maintainability. A simple, clear solution is easier to understand, debug, and modify than a complex and clever one. Before adding a new feature, a new dependency, or a new layer of abstraction, ask yourself: "Is there a simpler way to do this?" Often, the most elegant solution is the one with the fewest moving parts.</p>

        <h4>Examples of Applying KISS</h4>
        <ul>
          <li><strong>Prefer Data over Code:</strong> Instead of writing a complex `if/else if/else` or `switch` statement to handle different cases, see if you can drive the logic from a simple data structure like a dictionary or a map.</li>
          <li><strong>Choose Boring Technology:</strong> Don't adopt a new, trendy technology if a well-understood, "boring" one can do the job just as well. The novelty of a new tool often comes with a hidden cost in learning, hiring, and operational complexity.</li>
          <li><strong>Remove, Don't Add:</strong> When faced with a complex system, see if you can simplify it by removing code, features, or dependencies rather than adding more on top.</li>
        </ul>

        <h4>Bangladesh Analogy</h4>
        <p class="note">A common analogy in our local context: Don’t design and build a complex flyover to solve a traffic problem if a well-placed roundabout would manage the flow of traffic effectively for the foreseeable future. Start with the simplest viable solution.</p>

        <h4>Related Principles</h4>
        <ul>
          <li>KISS is closely related to <a href="#" onclick="showTopic('yagni', true); return false;">YAGNI</a>, as both principles help to prevent over-engineering.</li>
        </ul>
      </article>

      <article class="card topic" id="yagni" data-title="YAGNI (You Aren’t Gonna Need It)" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>YAGNI (You Aren’t Gonna Need It)</h2></div>
        <h4>Key Concept</h4>
        <p>YAGNI is a principle from Extreme Programming (XP) that advises developers to "always implement things when you actually need them, never when you just foresee that you need them." It is a strong argument against speculative development and building features that are not immediately required.</p>

        <h4>Core Learning</h4>
        <p>The core idea is to save time and resources by not building features that might never be used. The future is uncertain, and our predictions about what will be needed are often wrong. By focusing only on the current requirements, you can deliver value faster and avoid cluttering the codebase with unnecessary, untested, and un-maintained code. It takes discipline to apply YAGNI, as it often feels counter-intuitive to not build for the future.</p>

        <h4>Examples of Applying YAGNI</h4>
        <ul>
          <li><strong>No Speculative Extensibility:</strong> Avoid adding extension points, hooks, or abstract base classes for features that no user has asked for. It's often harder to build a correct abstraction without a concrete use case.</li>
          <li><strong>Keep APIs Minimal:</strong> When designing an API, only add the parameters and methods that are required for the current use case. It is easier to add a new parameter later than to remove an existing one that is being used by clients.</li>
          <li><strong>Don't Add Unused Options:</strong> Avoid adding configuration options or settings for things that are not needed right now. Every option adds to the complexity of testing and maintenance.</li>
        </ul>

        <h4>When to Break YAGNI?</h4>
        <p class="note">While YAGNI is a powerful principle, there are exceptions. For example, when designing a public API that will be used by many clients, it might be worth investing in some forward-thinking design to ensure stability. Similarly, for foundational aspects like security and scalability, some upfront investment is often necessary. The key is to be deliberate and have a strong justification for any feature that is not driven by an immediate need.</p>

        <h4>Related Principles</h4>
        <ul>
          <li>YAGNI is a more extreme version of <a href="#" onclick="showTopic('kiss', true); return false;">KISS</a>. While KISS is about simplicity of design, YAGNI is about simplicity of scope.</li>
        </ul>
      </article>

      <article class="card topic" id="soc" data-title="Separation of Concerns" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>Separation of Concerns</h2></div>
        <h4>Key Concept</h4>
        <p>Separation of Concerns (SoC) is a design principle for partitioning a computer program into distinct sections, such that each section addresses a separate concern. A concern is a set of information that affects the code of a computer program. By separating concerns, we make the system more modular, easier to understand, and easier to maintain.</p>

        <h4>Core Learning</h4>
        <p>The main goal of SoC is to reduce complexity. When concerns are mixed, the code becomes tangled and hard to change. For example, if you mix database query logic inside your UI code, a change to the database schema could force you to change the UI code, which makes no logical sense. By separating these concerns, you can modify one part of the system without unintentionally affecting other parts.</p>

        <h4>Examples of SoC in Practice</h4>
        <ul>
          <li><strong>Layered Architecture:</strong> The classic example of SoC is the <a href="#" onclick="showTopic('layered', true); return false;">Layered Architecture</a>, which separates the system into Presentation (UI), Application (Service), Domain (Business Logic), and Infrastructure (Persistence, Logging) layers.</li>
          <li><strong>Model-View-Controller (MVC):</strong> A common pattern in web applications that separates the concerns of data (Model), presentation (View), and user input (Controller).</li>
          <li><strong>Component-Based Design:</strong> In frontend development, frameworks like React or Vue encourage you to build self-contained components, each with its own markup, styling, and logic. This is another form of SoC.</li>
        </ul>

        <h4>Code Example (Conceptual)</h4>
        <pre><button class="copy">Copy</button><code>// A classic example of layering, a form of SoC.

// Concern: Presentation (e.g., ASP.NET Core Controller)
public class OrderController : ControllerBase {
  private readonly IOrderService _service;
  public OrderController(IOrderService service) => _service = service;

  [HttpPost]
  public async Task<IActionResult> PlaceOrder(OrderDto order) {
    await _service.PlaceOrderAsync(order);
    return Ok();
  }
}

// Concern: Application/Domain Logic
public interface IOrderService { Task PlaceOrderAsync(OrderDto order); }
public class OrderService : IOrderService {
  private readonly IOrderRepository _repo;
  public OrderService(IOrderRepository repo) => _repo = repo;

  public async Task PlaceOrderAsync(OrderDto dto) {
    var order = new Order(dto.Id, dto.Amount); // Domain logic here
    await _repo.SaveAsync(order);
  }
}

// Concern: Infrastructure (Data Access)
public interface IOrderRepository { Task SaveAsync(Order order); }
public class OrderRepository : IOrderRepository {
  private readonly DbContext _db;
  public OrderRepository(DbContext db) => _db = db;

  public async Task SaveAsync(Order order) {
    _db.Orders.Add(order);
    await _db.SaveChangesAsync();
  }
}
</code></pre>

        <h4>Related Principles</h4>
        <ul>
          <li>SoC is a foundational principle that enables other principles like <a href="#" onclick="showTopic('solid', true); return false;">SOLID</a> and <a href="#" onclick="showTopic('di', true); return false;">Dependency Inversion</a>.</li>
        </ul>
      </article>

      <article class="card topic" id="di" data-title="Dependency Inversion" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>Dependency Inversion</h2></div>
        <h4>Key Concept</h4>
        <p>The Dependency Inversion Principle (DIP) is the 'D' in <a href="#" onclick="showTopic('solid', true); return false;">SOLID</a>. It has two parts:</n          <ol>
            <li>High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces).</li>
            <li>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</li>
          </ol>
        This principle inverts the traditional flow of dependencies, where high-level modules directly depend on low-level ones.</p>

        <h4>Core Learning</h4>
        <p>The main benefit of DIP is decoupling. When your high-level business logic is not tied to specific implementation details (like a particular database or a specific email service), your code becomes much more flexible and easier to test. You can swap out implementations without changing the high-level code. For example, you can replace a real database with a fake one for testing purposes.</p>

        <h4>Example (C#)</h4>
        <p>The following example shows a `SignupService` (high-level module) that needs to send a notification. Instead of depending directly on a concrete `EmailNotifier` (low-level module), it depends on an `INotifier` interface (abstraction).</p>
        <pre><button class="copy">Copy</button><code>// The abstraction that both high-level and low-level modules depend on.
public interface INotifier {
  Task SendAsync(string to, string message);
}

// A concrete implementation (low-level detail).
public class EmailNotifier : INotifier {
  public Task SendAsync(string to, string message) {
    // Code to send an email...
    Console.WriteLine($"Sending email to {to}: {message}");
    return Task.CompletedTask;
  }
}

// Another concrete implementation.
public class SmsNotifier : INotifier {
  public Task SendAsync(string to, string message) {
    // Code to send an SMS...
    Console.WriteLine($"Sending SMS to {to}: {message}");
    return Task.CompletedTask;
  }
}

// The high-level module that depends on the abstraction.
public class SignupService {
  private readonly INotifier _notifier;

  // The dependency is "injected" via the constructor.
  public SignupService(INotifier notifier) {
    _notifier = notifier;
  }

  public Task SignupAsync(User user) {
    // The service doesn't know or care if it's sending an email or an SMS.
    return _notifier.SendAsync(user.Email, "Welcome!");
  }
}
</code></pre>
        <p class="note"><strong>Dependency Injection (DI)</strong> is a common technique to implement this principle. DI is the mechanism by which the concrete implementations (like `EmailNotifier`) are provided to the high-level modules (like `SignupService`) at runtime, usually by a DI container or framework.</p>
      </article>

      <!-- ===== SOLID ===== -->
      <article class="card topic" id="solid" data-title="SOLID" data-category="Principles">
        <div class="title"><span class="tag">Principles</span><h2>SOLID</h2></div>
        <h4>Key Concept</h4>
        <p>SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible, and maintainable. They are a set of rules and best practices to follow while designing a class or module. When applied together, they help developers create systems that are easy to maintain and extend over time.</p>

        <h4>Core Learning</h4>
        <p>SOLID principles are the bedrock of good object-oriented design. They guide you to create code that is decoupled, cohesive, and easy to test. Mastering SOLID is a key step in moving from just writing code to designing robust software solutions. While they are presented as five separate principles, they are all interconnected and support each other.</p>

        <h4>The Five SOLID Principles</h4>
        <ul>
          <li><strong>S - Single Responsibility Principle (SRP):</strong> A class should have only one reason to change. This means a class should have only one job or responsibility. This is related to <a href="#" onclick="showTopic('soc', true); return false;">Separation of Concerns</a>.</li>
          <li><strong>O - Open/Closed Principle (OCP):</strong> Software entities (classes, modules, functions) should be open for extension, but closed for modification. This means you should be able to add new functionality without changing existing code.</li>
          <li><strong>L - Liskov Substitution Principle (LSP):</strong> Subtypes must be substitutable for their base types. This means that objects of a superclass should be replaceable with objects of its subclasses without breaking the application.</li>
          <li><strong>I - Interface Segregation Principle (ISP):</strong> No client should be forced to depend on methods it does not use. This means that you should favor many small, client-specific interfaces over one large, general-purpose interface.</li>
          <li><strong>D - <a href="#" onclick="showTopic('di', true); return false;">Dependency Inversion Principle (DIP)</a>:</strong> High-level modules should not depend on low-level modules. Both should depend on abstractions. This is the core principle for creating decoupled systems.</li>
        </ul>
        <p class="note">Each of these principles deserves its own detailed study. The guide provides a dedicated section for the Dependency Inversion Principle.</p>
      </article>

      <!-- ===== Design Patterns (Creational / Structural / Behavioral / Enterprise) ===== -->
      <article class="card topic" id="design-patterns" data-title="Design Patterns (Overview)" data-category="Patterns">
        <div class="title"><span class="tag">Patterns</span><h2>Design Patterns — Overview</h2></div>
        <h4>Key Concept</h4>
        <p>Design patterns are reusable, well-documented solutions to commonly occurring problems within a given context in software design. They are not finished designs that can be transformed directly into code; rather, they are descriptions or templates for how to solve a problem that can be used in many different situations. They represent the collective wisdom of experienced software developers.</p>

        <h4>Core Learning</h4>
        <p>The main idea behind design patterns is to provide a common vocabulary and a set of proven solutions for software design. By using design patterns, you can build on the experience of others instead of reinventing the wheel. It's important to understand the problem that a pattern solves, not just the pattern itself. A common mistake is to force a pattern where it doesn't fit. Always start with the problem, and then see if a pattern can help you solve it in an elegant way. A good principle to follow is to favor composition over inheritance.</p>

        <h4>Categories of Design Patterns</h4>
        <ul>
          <li><strong>Creational Patterns:</strong> These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Examples include <a href="#" onclick="showTopic('factory', true); return false;">Factory</a>, <a href="#" onclick="showTopic('singleton', true); return false;">Singleton</a>, and <a href="#" onclick="showTopic('builder', true); return false;">Builder</a>.</li>
          <li><strong>Structural Patterns:</strong> These patterns ease the design by identifying a simple way to realize relationships between entities. Examples include <a href="#" onclick="showTopic('adapter', true); return false;">Adapter</a>, <a href="#" onclick="showTopic('composite', true); return false;">Composite</a>, <a href="#" onclick="showTopic('proxy', true); return false;">Proxy</a>, and <a href="#" onclick="showTopic('facade', true); return false;">Facade</a>.</li>
          <li><strong>Behavioral Patterns:</strong> These patterns are concerned with algorithms and the assignment of responsibilities between objects. Examples include <a href="#" onclick="showTopic('observer', true); return false;">Observer</a>, <a href="#" onclick="showTopic('strategy', true); return false;">Strategy</a>, and <a href="#" onclick="showTopic('command', true); return false;">Command</a>.</li>
          <li><strong>Enterprise Patterns:</strong> These are patterns for building robust, scalable, and maintainable enterprise applications. Examples include <a href="#" onclick="showTopic('repository', true); return false;">Repository</a>, <a href="#" onclick="showTopic('uow', true); return false;">Unit of Work</a>, <a href="#" onclick="showTopic('cqrs', true); return false;">CQRS</a>, and <a href="#" onclick="showTopic('event-sourcing', true); return false;">Event Sourcing</a>.</li>
        </ul>
      </article>

      <!-- Creational -->
      <article class="card topic" id="factory" data-title="Factory" data-category="Patterns: Creational">
        <div class="title"><span class="tag">Creational</span><h2>Factory</h2></div>
        <h4>Key Concept</h4>
        <p>The Factory Method pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. It's a creational pattern that decouples the client code from the concrete classes you need to instantiate.</p>

        <h4>Core Learning</h4>
        <p>Use the Factory pattern when you have a class that cannot anticipate the class of objects it must create. The Factory encapsulates the creation logic, so the client code doesn't need to know the specifics of how to create an object. This makes your code more flexible and easier to extend. If you need to add a new type of object, you just need to add a new class and update the factory, without changing the client code.</p>

        <h4>Example (C#)</h4>
        <p>In this example, we have a `PaymentFactory` that creates different types of payment processors based on a string identifier. The client code that uses the factory doesn't need to know about `BkashPayment` or `NagadPayment` classes.</p>
        <pre><button class="copy">Copy</button><code>// The common interface for all payment processors.
public interface IPayment {
  void Pay(decimal amount);
}

// Concrete implementation for bKash.
public class BkashPayment : IPayment {
  public void Pay(decimal amount) {
    Console.WriteLine($"Paying {amount} via bKash.");
  }
}

// Concrete implementation for Nagad.
public class NagadPayment : IPayment {
  public void Pay(decimal amount) {
    Console.WriteLine($"Paying {amount} via Nagad.");
  }
}

// The Factory class that creates the objects.
public static class PaymentFactory {
  public static IPayment Create(string method) {
    return method.ToLower() switch {
      "bkash" => new BkashPayment(),
      "nagad" => new NagadPayment(),
      _ => throw new NotSupportedException($"Payment method '{method}' is not supported.")
    };
  }
}

// Client code.
public class CheckoutService {
  public void ProcessPayment(string paymentMethod, decimal amount) {
    IPayment paymentProcessor = PaymentFactory.Create(paymentMethod);
    paymentProcessor.Pay(amount);
  }
}
</code></pre>
        <p class="note">This pattern is particularly useful when the object creation process is complex or when you want to provide a way for clients to extend the set of created objects (e.g., by registering new types with the factory).</p>
      </article>

      <article class="card topic" id="singleton" data-title="Singleton" data-category="Patterns: Creational">
        <div class="title"><span class="tag">Creational</span><h2>Singleton</h2></div>
        <h4>Key Concept</h4>
        <p>The Singleton pattern ensures that a class has only one instance, and provides a global point of access to it. This is useful when exactly one object is needed to coordinate actions across the system, for example, a configuration manager or a logger.</p>

        <h4>Core Learning</h4>
        <p>While the Singleton pattern is simple to understand, it is often overused and can lead to problems. It introduces a global state into the application, which can make testing difficult (as you can't easily mock a singleton). It also violates the <a href="#" onclick="showTopic('solid', true); return false;">Single Responsibility Principle</a>, as the class is responsible for both its own logic and for managing its own lifecycle. In modern applications, it is often better to use a dependency injection container to manage the lifecycle of your objects as singletons, rather than implementing the pattern yourself.</p>

        <h4>Example (C#)</h4>
        <p>This example shows a thread-safe implementation of the Singleton pattern in C# using `Lazy<T>` to ensure that the instance is created only when it is first accessed.</p>
        <pre><button class="copy">Copy</button><code>public sealed class AppConfig {
  // The private static field that will hold the single instance.
  // Lazy<T> makes the initialization thread-safe and lazy.
  private static readonly Lazy<AppConfig> _lazyInstance = new(() => new AppConfig());

  // The public static property to access the instance.
  public static AppConfig Instance => _lazyInstance.Value;

  // The private constructor prevents instantiation from outside the class.
  private AppConfig() {
    // Load configuration from a file or other source.
    Console.WriteLine("AppConfig instance created.");
  }

  // Example configuration property.
  public string GetApiUrl() => "https://api.example.com";
}

// Client code.
public class SomeService {
  public void DoWork() {
    string apiUrl = AppConfig.Instance.GetApiUrl();
    // ...
  }
}
</code></pre>

        <h4>Watch-outs</h4>
        <ul>
          <li class="warn"><strong>Testability Issues:</strong> Singletons are hard to mock or stub in unit tests. This can make your tests slow and dependent on the real implementation.</li>
          <li class="warn"><strong>Hidden Dependencies:</strong> When a class uses a singleton, its dependency on that singleton is hidden in the code, not exposed in its public API. This makes the code harder to understand and reuse.</li>
        </ul>
      </article>

      <article class="card topic" id="builder" data-title="Builder" data-category="Patterns: Creational">
        <div class="title"><span class="tag">Creational</span><h2>Builder</h2></div>
        <h4>Key Concept</h4>
        <p>The Builder pattern is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code. It is particularly useful when an object has many configuration options or when the creation process is complex.</p>

        <h4>Core Learning</h4>
        <p>The main advantage of the Builder pattern is that it separates the construction of a complex object from its representation. This means you can use the same construction process to create different representations of the object. It also improves readability by making the code that creates the object look like a fluent, readable API. This is a great alternative to having constructors with a large number of optional parameters (a "telescoping constructor" anti-pattern).</p>

        <h4>Example (C#)</h4>
        <p>This example shows how to build a `Report` object with various optional parts using a fluent `ReportBuilder`.</p>
        <pre><button class="copy">Copy</button><code>// The complex object we want to build.
public class Report {
  public string Title { get; set; }
  public bool HasHeader { get; set; }
  public bool HasFooter { get; set; }
  public bool HasChart { get; set; }
  public bool HasTable { get; set; }

  public void Display() {
    Console.WriteLine($"--- Report: {Title} ---");
    if (HasHeader) Console.WriteLine("Header");
    if (HasChart) Console.WriteLine("Chart");
    if (HasTable) Console.WriteLine("Table");
    if (HasFooter) Console.WriteLine("Footer");
  }
}

// The Builder class with a fluent interface.
public class ReportBuilder {
  private readonly Report _report = new();

  public ReportBuilder Title(string title) {
    _report.Title = title;
    return this;
  }

  public ReportBuilder AddHeader() {
    _report.HasHeader = true;
    return this;
  }

  public ReportBuilder AddFooter() {
    _report.HasFooter = true;
    return this;
  }

  public ReportBuilder AddChart() {
    _report.HasChart = true;
    return this;
  }

  public ReportBuilder AddTable() {
    _report.HasTable = true;
    return this;
  }

  public Report Build() {
    return _report;
  }
}

// Client code.
public class ReportGenerator {
  public void GenerateSalesReport() {
    var builder = new ReportBuilder();
    var salesReport = builder
      .Title("Monthly Sales Report")
      .AddHeader()
      .AddChart()
      .AddTable()
      .AddFooter()
      .Build();

    salesReport.Display();
  }
}
</code></pre>
      </article>

      <!-- Structural -->
      <article class="card topic" id="adapter" data-title="Adapter" data-category="Patterns: Structural">
        <div class="title"><span class="tag">Structural</span><h2>Adapter</h2></div>
        <h4>Key Concept</h4>
        <p>The Adapter pattern is a structural design pattern that allows objects with incompatible interfaces to collaborate. It acts as a wrapper between two objects, catching calls for one object and transforming them into a format and interface recognizable by the other.</p>

        <h4>Core Learning</h4>
        <p>Use the Adapter pattern when you want to use an existing class, but its interface is not compatible with the rest of your code. This often happens when you are integrating a third-party library or a legacy component. The Adapter lets you use the functionality of the existing class without changing its source code, and without your client code knowing about the incompatibility.</p>

        <h4>Example (C#)</h4>
        <p>In this example, our application uses an `INotification` interface to send messages. We want to use a third-party `SmsGateway` to send SMS messages, but it has a different interface (`Push` method). The `SmsAdapter` class wraps the `SmsGateway` and implements the `INotification` interface, translating the `Send` call to a `Push` call.</p>
        <pre><button class="copy">Copy</button><code>// The interface that our application uses.
public interface INotification {
  void Send(string to, string message);
}

// The third-party class with an incompatible interface.
public class SmsGateway {
  public void Push(string phoneNumber, string text) {
    Console.WriteLine($"Sending SMS to {phoneNumber}: {text}");
  }
}

// The Adapter class that makes the SmsGateway compatible with our application.
public class SmsAdapter : INotification {
  private readonly SmsGateway _smsGateway;

  public SmsAdapter(SmsGateway smsGateway) {
    _smsGateway = smsGateway;
  }

  public void Send(string to, string message) {
    // The adapter translates the call to the appropriate method.
    _smsGateway.Push(to, message);
  }
}

// Client code.
public class NotificationService {
  public void SendNotification(INotification notification, string recipient, string message) {
    notification.Send(recipient, message);
  }
}

// Somewhere in the application setup:
var smsGateway = new SmsGateway();
var smsAdapter = new SmsAdapter(smsGateway);
var notificationService = new NotificationService();
notificationService.SendNotification(smsAdapter, "+880123456789", "Your order has shipped!");
</code></pre>
      </article>

      <article class="card topic" id="composite" data-title="Composite" data-category="Patterns: Structural">
        <div class="title"><span class="tag">Structural</span><h2>Composite</h2></div>
        <h4>Key Concept</h4>
        <p>The Composite pattern is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects. It allows clients to treat individual objects (leaves) and compositions of objects (composites) uniformly.</p>

        <h4>Core Learning</h4>
        <p>Use the Composite pattern when you have a part-whole hierarchy and you want to be able to treat all objects in the hierarchy in the same way. A classic example is a graphical user interface, where a window can contain panels, which can contain buttons, text fields, and other panels. The Composite pattern allows you to apply an operation (like `draw()`) to the entire tree, and it will recursively be applied to all the children.</p>

        <h4>Example (C#)</h4>
        <p>This example shows a simple file system structure. Both `File` (a leaf) and `Directory` (a composite) implement the `IFileSystemItem` interface, so they can be treated uniformly. A directory can contain files or other directories.</p>
        <pre><button class="copy">Copy</button><code>// The common interface for both simple (leaf) and complex (composite) objects.
public interface IFileSystemItem {
  string Name { get; }
  int GetSize();
}

// The Leaf class represents a simple object.
public class File : IFileSystemItem {
  public string Name { get; }
  private readonly int _size;

  public File(string name, int size) {
    Name = name;
    _size = size;
  }

  public int GetSize() => _size;
}

// The Composite class represents a complex object that can have children.
public class Directory : IFileSystemItem {
  public string Name { get; }
  private readonly List<IFileSystemItem> _children = new();

  public Directory(string name) {
    Name = name;
  }

  public void Add(IFileSystemItem item) {
    _children.Add(item);
  }

  public int GetSize() {
    // The size of the directory is the sum of the sizes of its children.
    return _children.Sum(child => child.GetSize());
  }
}

// Client code.
public class FileSystemExplorer {
  public void Explore() {
    var root = new Directory("root");
    var music = new Directory("music");
    music.Add(new File("song1.mp3", 4000));
    music.Add(new File("song2.mp3", 5000));
    root.Add(music);
    root.Add(new File("readme.txt", 100));

    // We can get the size of the root directory without knowing its contents.
    Console.WriteLine($"Total size: {root.GetSize()}"); // Outputs 9100
  }
}
</code></pre>
      </article>

      <article class="card topic" id="proxy" data-title="Proxy" data-category="Patterns: Structural">
        <div class="title"><span class="tag">Structural</span><h2>Proxy</h2></div>
        <h4>Key Concept</h4>
        <p>The Proxy pattern provides a surrogate or placeholder for another object to control access to it. A proxy object has the same interface as the real object it is proxying, which allows it to be substituted for the real object. The proxy can then add extra logic before or after delegating the call to the real object.</p>

        <h4>Core Learning</h4>
        <p>Use the Proxy pattern when you want to add a layer of control over access to an object. There are several types of proxies, each for a different purpose:</p>
        <ul>
          <li><strong>Remote Proxy:</strong> Represents an object in a different address space (e.g., on a remote server).</li>
          <li><strong>Virtual Proxy:</strong> Creates expensive objects on demand (lazy initialization).</li>
          <li><strong>Protection Proxy:</strong> Controls access to the methods of an object based on the caller's permissions.</li>
          <li><strong>Caching Proxy:</strong> Caches the results of expensive operations and returns the cached result when the operation is called again with the same arguments.</li>
        </ul>

        <h4>Example (C# - Caching Proxy)</h4>
        <p>This example shows a caching proxy for a video downloading service. The `CachedVideoDownloader` acts as a proxy for the `RealVideoDownloader`. When a video is requested, the proxy first checks if it's already in the cache. If it is, it returns the cached video; otherwise, it calls the real downloader, caches the result, and then returns it.</p>
        <pre><button class="copy">Copy</button><code>// The common interface for the real object and the proxy.
public interface IVideoDownloader {
  Task<byte[]> DownloadVideoAsync(string url);
}

// The real object that does the expensive work.
public class RealVideoDownloader : IVideoDownloader {
  public async Task<byte[]> DownloadVideoAsync(string url) {
    Console.WriteLine($"Downloading video from {url}...");
    // Simulate a network call.
    await Task.Delay(2000);
    return new byte[1024]; // Dummy video data
  }
}

// The Proxy class that adds caching.
public class CachedVideoDownloader : IVideoDownloader {
  private readonly RealVideoDownloader _realDownloader;
  private readonly Dictionary<string, byte[]> _cache = new();

  public CachedVideoDownloader(RealVideoDownloader realDownloader) {
    _realDownloader = realDownloader;
  }

  public async Task<byte[]> DownloadVideoAsync(string url) {
    if (_cache.ContainsKey(url)) {
      Console.WriteLine($"Returning cached video for {url}.");
      return _cache[url];
    }

    var videoData = await _realDownloader.DownloadVideoAsync(url);
    _cache[url] = videoData;
    return videoData;
  }
}

// Client code.
public class VideoPlayer {
  public async Task PlayVideo(string url) {
    var downloader = new CachedVideoDownloader(new RealVideoDownloader());
    var video = await downloader.DownloadVideoAsync(url); // First time, downloads
    var video2 = await downloader.DownloadVideoAsync(url); // Second time, from cache
  }
}
</code></pre>
      </article>

      <article class="card topic" id="facade" data-title="Facade" data-category="Patterns: Structural">
        <div class="title"><span class="tag">Structural</span><h2>Facade</h2></div>
        <h4>Key Concept</h4>
        <p>The Facade pattern provides a simplified, high-level interface to a larger body of code, such as a complex subsystem or a library. It hides the complexity of the subsystem and provides a more convenient API for the client code.</p>

        <h4>Core Learning</h4>
        <p>Use the Facade pattern when you have a complex subsystem that is difficult to use because it has many classes and a complicated API. The Facade can provide a simple entry point to the subsystem's functionality. This promotes loose coupling between the client and the subsystem, as the client only needs to know about the Facade, not the dozens of classes behind it. This makes the client code simpler and easier to maintain.</p>

        <h4>Example (C#)</h4>
        <p>In this example, we have a complex home theater system with separate components for the amplifier, tuner, DVD player, and projector. The `HomeTheaterFacade` provides a simple interface with methods like `WatchMovie()` and `EndMovie()`, which orchestrate the necessary calls to the underlying components.</p>
        <pre><button class="copy">Copy</button><code>// Complex subsystem components
public class Amplifier { public void On() => Console.WriteLine("Amplifier on"); }
public class Tuner { public void On() => Console.WriteLine("Tuner on"); }
public class DvdPlayer { public void On() => Console.WriteLine("DVD Player on"); public void Play(string movie) => Console.WriteLine($"Playing \"{movie}\""); }
public class Projector { public void On() => Console.WriteLine("Projector on"); }

// The Facade class that simplifies the subsystem.
public class HomeTheaterFacade {
  private readonly Amplifier _amp;
  private readonly Tuner _tuner;
  private readonly DvdPlayer _dvd;
  private readonly Projector _projector;

  public HomeTheaterFacade(Amplifier amp, Tuner tuner, DvdPlayer dvd, Projector projector) {
    _amp = amp; _tuner = tuner; _dvd = dvd; _projector = projector;
  }

  public void WatchMovie(string movie) {
    Console.WriteLine("Get ready to watch a movie...");
    _amp.On();
    _tuner.On();
    _dvd.On();
    _projector.On();
    _dvd.Play(movie);
  }

  public void EndMovie() {
    Console.WriteLine("Shutting movie theater down...");
    // ... turn off all components
  }
}

// Client code.
public class HomeTheaterEnthusiast {
  public void EnjoyMovie() {
    var facade = new HomeTheaterFacade(new Amplifier(), new Tuner(), new DvdPlayer(), new Projector());
    facade.WatchMovie("The Matrix");
  }
}
</code></pre>
        <p class="note">The Facade doesn't encapsulate the subsystem entirely. The client can still access the underlying classes if they need more advanced functionality. The Facade just provides a simpler alternative for the most common use cases.</p>
      </article>

      <!-- Behavioral -->
      <article class="card topic" id="observer" data-title="Observer" data-category="Patterns: Behavioral">
        <div class="title"><span class="tag">Behavioral</span><h2>Observer</h2></div>
        <h4>Key Concept</h4>
        <p>The Observer pattern is a behavioral design pattern that defines a one-to-many dependency between objects. When one object (the subject or publisher) changes its state, all its dependents (the observers or subscribers) are notified and updated automatically. This is also known as the Publish/Subscribe (Pub/Sub) pattern.</p>

        <h4>Core Learning</h4>
        <p>Use the Observer pattern when you have a situation where a change in one object needs to be reflected in other, unrelated objects without coupling them tightly. The subject and observers are loosely coupled; the subject only knows that it has a list of observers, each conforming to a specific interface. It doesn't know the concrete classes of the observers. This allows you to add new observers without changing the subject's code.</p>

        <h4>Example (C#)</h4>
        <p>In this example, a `WeatherStation` (the subject) notifies multiple `IDisplay` observers whenever the temperature changes. The `CurrentConditionsDisplay` and `ForecastDisplay` are concrete observers that react to the notification.</p>
        <pre><button class="copy">Copy</button><code>// The Observer interface.
public interface IDisplay {
  void Update(float temperature);
}

// The Subject (or Publisher).
public class WeatherStation {
  private readonly List<IDisplay> _displays = new();
  private float _temperature;

  public void Add(IDisplay display) => _displays.Add(display);
  public void Remove(IDisplay display) => _displays.Remove(display);

  public void SetTemperature(float temp) {
    _temperature = temp;
    Notify();
  }

  private void Notify() {
    foreach (var display in _displays) {
      display.Update(_temperature);
    }
  }
}

// Concrete Observers.
public class CurrentConditionsDisplay : IDisplay {
  public void Update(float temperature) => Console.WriteLine($"Current conditions: {temperature}C");
}

public class ForecastDisplay : IDisplay {
  public void Update(float temperature) => Console.WriteLine($"Forecast: Expect warmer weather.");
}

// Client code.
var station = new WeatherStation();
station.Add(new CurrentConditionsDisplay());
station.Add(new ForecastDisplay());

station.SetTemperature(25.5f);
// Both displays will be notified and print their messages.
</code></pre>
        <p class="note">In modern C#, this pattern is often implemented using events (`event` and `delegate`) which provide a built-in way to handle publish/subscribe scenarios.</p>
      </article>

      <article class="card topic" id="strategy" data-title="Strategy" data-category="Patterns: Behavioral">
        <div class="title"><span class="tag">Behavioral</span><h2>Strategy</h2></div>
        <h4>Key Concept</h4>
        <p>The Strategy pattern is a behavioral design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives runtime instructions as to which in a family of algorithms to use. It defines a family of algorithms, encapsulates each one, and makes them interchangeable.</p>

        <h4>Core Learning</h4>
        <p>Use the Strategy pattern when you have a task that can be performed in multiple ways, and you want to be able to switch between these ways easily. This pattern lets you vary the algorithm independently from the clients that use it. It helps to avoid complex conditional statements (e.g., `if/else` or `switch` blocks) for selecting an algorithm, and it follows the <a href="#" onclick="showTopic('solid', true); return false;">Open/Closed Principle</a>, as you can introduce new strategies without changing the context class.</p>

        <h4>Example (C#)</h4>
        <p>In this example, a `ShippingCalculator` can calculate the cost of shipping using different strategies. We have strategies for FedEx, UPS, and USPS. The `ShippingCalculator` (the context) is configured with a specific strategy and uses it to calculate the cost.</p>
        <pre><button class="copy">Copy</button><code>// The Strategy interface.
public interface IShippingStrategy {
  decimal Calculate(Order order);
}

// Concrete Strategies.
public class FedExShippingStrategy : IShippingStrategy {
  public decimal Calculate(Order order) => 5.00m;
}
public class UpsShippingStrategy : IShippingStrategy {
  public decimal Calculate(Order order) => 4.50m;
}
public class UspsShippingStrategy : IShippingStrategy {
  public decimal Calculate(Order order) => 3.75m;
}

// The Context class that uses a strategy.
public class ShippingCalculator {
  private IShippingStrategy _shippingStrategy;

  public void SetStrategy(IShippingStrategy strategy) {
    _shippingStrategy = strategy;
  }

  public decimal CalculateShippingCost(Order order) {
    return _shippingStrategy.Calculate(order);
  }
}

// Client code.
var order = new Order();
var calculator = new ShippingCalculator();

calculator.SetStrategy(new FedExShippingStrategy());
var cost1 = calculator.CalculateShippingCost(order); // 5.00m

calculator.SetStrategy(new UpsShippingStrategy());
var cost2 = calculator.CalculateShippingCost(order); // 4.50m
</code></pre>
      </article>

      <article class="card topic" id="command" data-title="Command" data-category="Patterns: Behavioral">
        <div class="title"><span class="tag">Behavioral</span><h2>Command</h2></div>
        <h4>Key Concept</h4>
        <p>The Command pattern is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations.</p>

        <h4>Core Learning</h4>
        <p>Use the Command pattern when you want to decouple the object that invokes an operation from the object that knows how to perform it. This is useful for building systems with features like undo/redo, queuing requests, or logging operations. The invoker doesn't need to know anything about the concrete command; it just needs to know how to execute a command.</p>

        <h4>Example (C#)</h4>
        <p>This example shows a simple remote control for a light. The `LightOnCommand` and `LightOffCommand` encapsulate the requests to turn a light on and off. The `RemoteControl` (the invoker) can be configured with any command and execute it.</p>
        <pre><button class="copy">Copy</button><code>// The Command interface.
public interface ICommand {
  void Execute();
}

// The Receiver class that performs the actual work.
public class Light {
  public void TurnOn() => Console.WriteLine("The light is on");
  public void TurnOff() => Console.WriteLine("The light is off");
}

// Concrete Command to turn the light on.
public class LightOnCommand : ICommand {
  private readonly Light _light;
  public LightOnCommand(Light light) => _light = light;
  public void Execute() => _light.TurnOn();
}

// Concrete Command to turn the light off.
public class LightOffCommand : ICommand {
  private readonly Light _light;
  public LightOffCommand(Light light) => _light = light;
  public void Execute() => _light.TurnOff();
}

// The Invoker class.
public class RemoteControl {
  private ICommand _command;

  public void SetCommand(ICommand command) {
    _command = command;
  }

  public void PressButton() {
    _command.Execute();
  }
}

// Client code.
var light = new Light();
var remote = new RemoteControl();

remote.SetCommand(new LightOnCommand(light));
remote.PressButton(); // The light is on

remote.SetCommand(new LightOffCommand(light));
remote.PressButton(); // The light is off
</code></pre>
      </article>

      <!-- Enterprise patterns -->
      <article class="card topic" id="repository" data-title="Repository" data-category="Patterns: Enterprise">
        <div class="title"><span class="tag">Enterprise</span><h2>Repository Pattern</h2></div>
        
        <h4>Key Concept</h4>
        <p>The Repository pattern encapsulates the logic needed to access data sources. It centralizes common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer. It provides a collection-like interface for accessing domain objects.</p>
        
        <h4>Core Learning</h4>
        <p>Use Repository when you want to decouple business logic from data access logic. It creates a uniform interface for accessing your domain objects, regardless of whether you're using SQL Server, MongoDB, or in-memory storage. This pattern is especially powerful when combined with Unit of Work and Dependency Injection.</p>
        
        <h4>Example (C# with Entity Framework)</h4>
        <pre><button class="copy">Copy</button><code>// Domain entity
public class Order {
  public Guid Id { get; set; }
  public string CustomerEmail { get; set; }
  public decimal TotalAmount { get; set; }
  public DateTime CreatedAt { get; set; }
  public List<OrderItem> Items { get; set; } = new();
}

// Repository interface (in domain layer)
public interface IOrderRepository {
  Task<Order?> GetByIdAsync(Guid id);
  Task<Order?> GetByCustomerEmailAsync(string email);
  Task<IEnumerable<Order>> GetOrdersCreatedAfterAsync(DateTime date);
  Task AddAsync(Order order);
  Task UpdateAsync(Order order);
  Task DeleteAsync(Guid id);
}

// Repository implementation (in infrastructure layer)
public class OrderRepository : IOrderRepository {
  private readonly AppDbContext _context;
  
  public OrderRepository(AppDbContext context) => _context = context;
  
  public async Task<Order?> GetByIdAsync(Guid id) {
    return await _context.Orders
      .Include(o => o.Items)
      .FirstOrDefaultAsync(o => o.Id == id);
  }
  
  public async Task<Order?> GetByCustomerEmailAsync(string email) {
    return await _context.Orders
      .Include(o => o.Items)
      .FirstOrDefaultAsync(o => o.CustomerEmail == email);
  }
  
  public async Task<IEnumerable<Order>> GetOrdersCreatedAfterAsync(DateTime date) {
    return await _context.Orders
      .Where(o => o.CreatedAt > date)
      .ToListAsync();
  }
  
  public async Task AddAsync(Order order) {
    await _context.Orders.AddAsync(order);
  }
  
  public async Task UpdateAsync(Order order) {
    _context.Orders.Update(order);
  }
  
  public async Task DeleteAsync(Guid id) {
    var order = await GetByIdAsync(id);
    if (order != null) {
      _context.Orders.Remove(order);
    }
  }
}

// Usage in application service
public class OrderService {
  private readonly IOrderRepository _orderRepo;
  private readonly IUnitOfWork _unitOfWork;
  
  public OrderService(IOrderRepository orderRepo, IUnitOfWork unitOfWork) {
    _orderRepo = orderRepo;
    _unitOfWork = unitOfWork;
  }
  
  public async Task<Order> CreateOrderAsync(string customerEmail, decimal amount) {
    var order = new Order {
      Id = Guid.NewGuid(),
      CustomerEmail = customerEmail,
      TotalAmount = amount,
      CreatedAt = DateTime.UtcNow
    };
    
    await _orderRepo.AddAsync(order);
    await _unitOfWork.SaveChangesAsync();
    
    return order;
  }
}</code></pre>
        
        <h4>Benefits & Trade-offs</h4>
        <div class="grid">
          <div>
            <h4>Benefits</h4>
            <ul>
              <li class="good"><strong>Testability:</strong> Easy to mock for unit tests</li>
              <li class="good"><strong>Flexibility:</strong> Switch data stores without changing business logic</li>
              <li class="good"><strong>Centralized Queries:</strong> All data access logic in one place</li>
              <li class="good"><strong>Domain Focus:</strong> Business logic doesn't know about SQL or databases</li>
            </ul>
          </div>
          <div>
            <h4>Trade-offs</h4>
            <ul>
              <li class="warn"><strong>Abstraction Overhead:</strong> Extra layer can hide performance issues</li>
              <li class="warn"><strong>Generic vs Specific:</strong> Balance between reusable and specific methods</li>
              <li class="bad"><strong>Over-abstraction:</strong> Don't create repositories for simple CRUD if ORM already provides good abstraction</li>
            </ul>
          </div>
        </div>
        
        <p class="note"><strong>Best Practice:</strong> Repository works best with aggregate roots in DDD. Avoid creating repositories for every entity - focus on meaningful domain boundaries.</p>
      </article>

      <article class="card topic" id="uow" data-title="Unit of Work" data-category="Patterns: Enterprise">
        <div class="title"><span class="tag">Enterprise</span><h2>Unit of Work Pattern</h2></div>
        
        <h4>Key Concept</h4>
        <p>The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates writing out changes and resolving concurrency problems. It tracks all changes made during a business transaction and ensures that all changes are committed or rolled back as a single atomic operation.</p>
        
        <h4>Core Learning</h4>
        <p>Unit of Work ensures data consistency by treating a series of operations as a single transaction. Instead of saving each change immediately, it collects all changes and commits them together. This prevents partial updates that could leave your data in an inconsistent state and improves performance by reducing database round trips.</p>
        
        <h4>Example (C# Implementation)</h4>
        <pre><button class="copy">Copy</button><code>// Unit of Work interface
public interface IUnitOfWork : IDisposable {
  IOrderRepository Orders { get; }
  ICustomerRepository Customers { get; }
  IProductRepository Products { get; }
  
  Task<int> SaveChangesAsync();
  Task BeginTransactionAsync();
  Task CommitTransactionAsync();
  Task RollbackTransactionAsync();
}

// Unit of Work implementation with Entity Framework
public class UnitOfWork : IUnitOfWork {
  private readonly AppDbContext _context;
  private IDbContextTransaction? _transaction;
  
  // Lazy initialization of repositories
  private IOrderRepository? _orders;
  private ICustomerRepository? _customers;
  private IProductRepository? _products;
  
  public UnitOfWork(AppDbContext context) {
    _context = context;
  }
  
  public IOrderRepository Orders => 
    _orders ??= new OrderRepository(_context);
    
  public ICustomerRepository Customers => 
    _customers ??= new CustomerRepository(_context);
    
  public IProductRepository Products => 
    _products ??= new ProductRepository(_context);
  
  public async Task<int> SaveChangesAsync() {
    try {
      return await _context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException ex) {
      // Handle concurrency conflicts
      throw new ConcurrencyException("Data was modified by another user", ex);
    }
  }
  
  public async Task BeginTransactionAsync() {
    _transaction = await _context.Database.BeginTransactionAsync();
  }
  
  public async Task CommitTransactionAsync() {
    if (_transaction != null) {
      await _transaction.CommitAsync();
      await _transaction.DisposeAsync();
      _transaction = null;
    }
  }
  
  public async Task RollbackTransactionAsync() {
    if (_transaction != null) {
      await _transaction.RollbackAsync();
      await _transaction.DisposeAsync();
      _transaction = null;
    }
  }
  
  public void Dispose() {
    _transaction?.Dispose();
    _context.Dispose();
  }
}

// Usage in application service
public class ECommerceService {
  private readonly IUnitOfWork _unitOfWork;
  
  public ECommerceService(IUnitOfWork unitOfWork) {
    _unitOfWork = unitOfWork;
  }
  
  public async Task ProcessOrderAsync(CreateOrderRequest request) {
    await _unitOfWork.BeginTransactionAsync();
    
    try {
      // Multiple operations that must succeed or fail together
      var customer = await _unitOfWork.Customers.GetByIdAsync(request.CustomerId);
      if (customer == null) {
        throw new CustomerNotFoundException();
      }
      
      var product = await _unitOfWork.Products.GetByIdAsync(request.ProductId);
      if (product == null || product.Stock < request.Quantity) {
        throw new InsufficientStockException();
      }
      
      // Create order
      var order = new Order {
        CustomerId = request.CustomerId,
        ProductId = request.ProductId,
        Quantity = request.Quantity,
        TotalAmount = product.Price * request.Quantity
      };
      
      await _unitOfWork.Orders.AddAsync(order);
      
      // Update product stock
      product.Stock -= request.Quantity;
      await _unitOfWork.Products.UpdateAsync(product);
      
      // Update customer points
      customer.LoyaltyPoints += (int)(order.TotalAmount * 0.1m);
      await _unitOfWork.Customers.UpdateAsync(customer);
      
      // Commit all changes as a single transaction
      await _unitOfWork.SaveChangesAsync();
      await _unitOfWork.CommitTransactionAsync();
      
    }
    catch (Exception) {
      await _unitOfWork.RollbackTransactionAsync();
      throw;
    }
  }
}

// Dependency Injection setup (in Program.cs or Startup.cs)
services.AddScoped<IUnitOfWork, UnitOfWork>();
services.AddScoped<IOrderRepository, OrderRepository>();
services.AddScoped<ICustomerRepository, CustomerRepository>();
services.AddScoped<IProductRepository, ProductRepository>();</code></pre>
        
        <h4>Benefits & Considerations</h4>
        <div class="grid">
          <div>
            <h4>Benefits</h4>
            <ul>
              <li class="good"><strong>Atomicity:</strong> All-or-nothing operations ensure data consistency</li>
              <li class="good"><strong>Performance:</strong> Reduces database round trips by batching changes</li>
              <li class="good"><strong>Transaction Management:</strong> Centralized control over database transactions</li>
              <li class="good"><strong>Testability:</strong> Easy to test complex business operations</li>
            </ul>
          </div>
          <div>
            <h4>Considerations</h4>
            <ul>
              <li class="warn"><strong>Complexity:</strong> Adds abstraction layer that might be overkill for simple apps</li>
              <li class="warn"><strong>Memory Usage:</strong> Holds objects in memory until commit</li>
              <li class="warn"><strong>Long Transactions:</strong> Can lead to deadlocks if transactions are too long</li>
              <li class="note"><strong>ORM Integration:</strong> Modern ORMs like EF Core already implement this pattern</li>
            </ul>
          </div>
        </div>
        
        <p class="note"><strong>Modern Note:</strong> Entity Framework Core's DbContext already implements Unit of Work pattern. You might not need a separate implementation unless you're working with multiple contexts or want additional abstraction.</p>
      </article>

      <article class="card topic" id="cqrs" data-title="CQRS" data-category="Patterns: Enterprise">
        <div class="title"><span class="tag">Enterprise</span><h2>CQRS</h2></div>
        <p>Split <em>commands</em> (writes) and <em>queries</em> (reads) to scale independently.</p>
        <ul><li>Pairs well with event sourcing and read models.</li></ul>
      </article>

      <article class="card topic" id="event-sourcing" data-title="Event Sourcing" data-category="Patterns: Enterprise">
        <div class="title"><span class="tag">Enterprise</span><h2>Event Sourcing</h2></div>
        <p>Persist domain <em>events</em> as the source of truth; rebuild state by replay.</p>
        <ul>
          <li class="good">Auditability & time travel.</li>
          <li class="bad">Event versioning and projections add complexity.</li>
        </ul>
      </article>

      <!-- ===== Architecture Styles & DDD ===== -->
      <article class="card topic" id="mono-vs-distributed" data-title="Monoliths vs. Distributed" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Monoliths vs. Distributed Systems</h2></div>
        
        <h4>Key Concept</h4>
        <p>The fundamental architectural decision between monolithic and distributed systems affects every aspect of your application: development, deployment, scaling, and maintenance. Understanding when to choose each approach is crucial for long-term success.</p>
        
        <h4>Core Learning</h4>
        <p>Start with a <strong>modular monolith</strong> and evolve to distributed systems only when you have clear business drivers. Distributed systems solve organizational and scaling problems but introduce significant operational complexity. The decision should be driven by team size, business requirements, and technical constraints - not by technology trends.</p>
        
        <div class="grid">
          <div>
            <h4>Monolithic Architecture</h4>
            <p><strong>Definition:</strong> Single deployable unit containing all application functionality.</p>
            
            <h5>Benefits:</h5>
            <ul>
              <li class="good"><strong>Simplicity:</strong> Easy to develop, test, debug, and deploy initially</li>
              <li class="good"><strong>Performance:</strong> No network calls between components</li>
              <li class="good"><strong>ACID Transactions:</strong> Database consistency is straightforward</li>
              <li class="good"><strong>Debugging:</strong> Single process, easier to trace issues</li>
              <li class="good"><strong>Tooling:</strong> Mature development and monitoring tools</li>
            </ul>
            
            <h5>Challenges:</h5>
            <ul>
              <li class="bad"><strong>Scaling Limitations:</strong> Must scale the entire application</li>
              <li class="bad"><strong>Technology Lock-in:</strong> Difficult to adopt new technologies</li>
              <li class="bad"><strong>Team Coordination:</strong> Single codebase can become bottleneck</li>
              <li class="warn"><strong>Deployment Risk:</strong> Single point of failure for deployments</li>
            </ul>
            
            <h5>When to Use:</h5>
            <ul>
              <li>Starting a new project or prototype</li>
              <li>Small to medium teams (< 10-15 developers)</li>
              <li>Predictable load patterns</li>
              <li>Strong consistency requirements</li>
            </ul>
          </div>
          
          <div>
            <h4>Distributed Systems</h4>
            <p><strong>Definition:</strong> Multiple independent services that communicate over the network to provide business functionality.</p>
            
            <h5>Benefits:</h5>
            <ul>
              <li class="good"><strong>Independent Scaling:</strong> Scale only the services that need it</li>
              <li class="good"><strong>Technology Diversity:</strong> Use the right tool for each service</li>
              <li class="good"><strong>Team Autonomy:</strong> Teams can work independently</li>
              <li class="good"><strong>Fault Isolation:</strong> Failure in one service doesn't bring down everything</li>
              <li class="good"><strong>Deployment Independence:</strong> Deploy services separately</li>
            </ul>
            
            <h5>Challenges:</h5>
            <ul>
              <li class="bad"><strong>Operational Complexity:</strong> Monitoring, logging, debugging across services</li>
              <li class="bad"><strong>Network Latency:</strong> Performance overhead of network calls</li>
              <li class="bad"><strong>Data Consistency:</strong> Eventual consistency and distributed transactions</li>
              <li class="bad"><strong>Testing Complexity:</strong> Integration testing across services</li>
              <li class="warn"><strong>Distributed System Fallacies:</strong> Network is unreliable, bandwidth is limited</li>
            </ul>
            
            <h5>When to Use:</h5>
            <ul>
              <li>Large teams (> 15-20 developers)</li>
              <li>Different scaling requirements per component</li>
              <li>Need for different technologies per service</li>
              <li>Mature DevOps practices in place</li>
            </ul>
          </div>
        </div>
        
        <h4>Migration Strategy: Modular Monolith First</h4>
        <pre><button class="copy">Copy</button><code>// Example: Modular Monolith Structure in .NET
MyECommerceApp/
├── src/
│   ├── Catalog/           // Bounded Context as Module
│   │   ├── Domain/
│   │   ├── Application/
│   │   └── Infrastructure/
│   ├── Orders/            // Another Bounded Context
│   │   ├── Domain/
│   │   ├── Application/
│   │   └── Infrastructure/
│   ├── Customers/
│   │   ├── Domain/
│   │   ├── Application/
│   │   └── Infrastructure/
│   └── Web/               // Presentation Layer
│       ├── Controllers/
│       └── Views/
└── tests/

// Each module has clear boundaries but shares database and deployment
// Can be extracted to microservices later when needed

// Module interface example
public interface ICatalogModule {
    Task<ProductDto> GetProductAsync(Guid productId);
    Task<IEnumerable<ProductDto>> SearchProductsAsync(string query);
}

// Implementation stays within module boundaries
internal class CatalogModule : ICatalogModule {
    private readonly ICatalogRepository _repository;
    
    public CatalogModule(ICatalogRepository repository) {
        _repository = repository;
    }
    
    public async Task<ProductDto> GetProductAsync(Guid productId) {
        var product = await _repository.GetByIdAsync(productId);
        return product?.ToDto();
    }
}</code></pre>
        
        <h4>Decision Framework</h4>
        <div class="grid">
          <div>
            <h5>Start with Monolith when:</h5>
            <ul>
              <li>Team size < 15 developers</li>
              <li>Product is in early stages</li>
              <li>Domain boundaries are unclear</li>
              <li>Strong consistency is required</li>
              <li>Limited DevOps maturity</li>
            </ul>
          </div>
          <div>
            <h5>Consider Distribution when:</h5>
            <ul>
              <li>Clear team/domain boundaries</li>
              <li>Different scaling requirements</li>
              <li>Need for technology diversity</li>
              <li>Mature CI/CD and monitoring</li>
              <li>Teams can handle operational complexity</li>
            </ul>
          </div>
        </div>
        
        <p class="note"><strong>Netflix's Approach:</strong> "We don't advocate for microservices. We advocate for teams owning the full lifecycle of their services. Microservices are a means to that end, not the end itself." - Start with what works for your team size and scale.</p>
      </article>

      <article class="card topic" id="layered" data-title="Layered (N-tier)" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Layered (N‑tier) Architecture</h2></div>
        
        <h4>Key Concept</h4>
        <p>Layered architecture organizes the system into horizontal layers where each layer only knows about and depends on the layers below it. This creates a clean separation of concerns and makes the system easier to understand, maintain, and test. It's the most common architectural pattern and serves as a good default for most applications.</p>
        
        <h4>Core Learning</h4>
        <p>The key principle is <strong>dependency direction</strong>: upper layers depend on lower layers, never the reverse. This creates a natural flow from user interface down to data storage. Each layer has specific responsibilities and should only communicate with adjacent layers, creating clear boundaries and reducing coupling.</p>
        
        <h4>Traditional 4-Layer Architecture</h4>
        <pre><button class="copy">Copy</button><code>┌─────────────────────────────────────┐
│           Presentation Layer         │  ← Controllers, Views, DTOs
├─────────────────────────────────────┤
│           Application Layer          │  ← Use Cases, Application Services
├─────────────────────────────────────┤
│             Domain Layer             │  ← Business Logic, Entities, Rules
├─────────────────────────────────────┤
│          Infrastructure Layer        │  ← Data Access, External Services
└─────────────────────────────────────┘

// Dependency Direction: ↓ (Top to Bottom Only)
// Data Flow: Both ↑ and ↓</code></pre>
        
        <h4>Layer Responsibilities</h4>
        <div class="grid">
          <div>
            <h5>Presentation Layer</h5>
            <ul>
              <li><strong>Purpose:</strong> Handle user interactions and display data</li>
              <li><strong>Contains:</strong> Controllers, Views, DTOs, View Models</li>
              <li><strong>Responsibilities:</strong>
                <ul>
                  <li>Accept user input and validate format</li>
                  <li>Transform domain objects to display format</li>
                  <li>Handle HTTP requests/responses</li>
                  <li>Authentication and basic authorization</li>
                </ul>
              </li>
            </ul>
            
            <h5>Application Layer</h5>
            <ul>
              <li><strong>Purpose:</strong> Orchestrate business operations</li>
              <li><strong>Contains:</strong> Application Services, Use Cases, Command Handlers</li>
              <li><strong>Responsibilities:</strong>
                <ul>
                  <li>Coordinate domain objects</li>
                  <li>Manage transactions</li>
                  <li>Handle cross-cutting concerns (logging, security)</li>
                  <li>Transform between layers</li>
                </ul>
              </li>
            </ul>
          </div>
          
          <div>
            <h5>Domain Layer</h5>
            <ul>
              <li><strong>Purpose:</strong> Contain business logic and rules</li>
              <li><strong>Contains:</strong> Entities, Value Objects, Domain Services, Business Rules</li>
              <li><strong>Responsibilities:</strong>
                <ul>
                  <li>Enforce business rules and invariants</li>
                  <li>Model the problem domain</li>
                  <li>Contain no technical concerns</li>
                  <li>Be technology-agnostic</li>
                </ul>
              </li>
            </ul>
            
            <h5>Infrastructure Layer</h5>
            <ul>
              <li><strong>Purpose:</strong> Handle external concerns</li>
              <li><strong>Contains:</strong> Repositories, External Services, Database Context</li>
              <li><strong>Responsibilities:</strong>
                <ul>
                  <li>Data persistence and retrieval</li>
                  <li>External API integrations</li>
                  <li>File system operations</li>
                  <li>Technical infrastructure</li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
        
        <h4>Implementation Example (C# .NET)</h4>
        <pre><button class="copy">Copy</button><code>// 1. PRESENTATION LAYER
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase {
    private readonly IOrderApplicationService _orderService;
    
    public OrdersController(IOrderApplicationService orderService) {
        _orderService = orderService;
    }
    
    [HttpPost]
    public async Task<ActionResult<OrderDto>> CreateOrder([FromBody] CreateOrderRequest request) {
        try {
            var order = await _orderService.CreateOrderAsync(request);
            return Ok(order.ToDto());
        }
        catch (InsufficientStockException ex) {
            return BadRequest(ex.Message);
        }
    }
}

// 2. APPLICATION LAYER
public class OrderApplicationService : IOrderApplicationService {
    private readonly IOrderRepository _orderRepo;
    private readonly IProductRepository _productRepo;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<OrderApplicationService> _logger;
    
    public OrderApplicationService(
        IOrderRepository orderRepo,
        IProductRepository productRepo,
        IUnitOfWork unitOfWork,
        ILogger<OrderApplicationService> logger) {
        _orderRepo = orderRepo;
        _productRepo = productRepo;
        _unitOfWork = unitOfWork;
        _logger = logger;
    }
    
    public async Task<Order> CreateOrderAsync(CreateOrderRequest request) {
        _logger.LogInformation("Creating order for customer {CustomerId}", request.CustomerId);
        
        // Coordinate domain operations
        var product = await _productRepo.GetByIdAsync(request.ProductId);
        if (product == null) {
            throw new ProductNotFoundException(request.ProductId);
        }
        
        // Use domain logic
        var order = Order.Create(request.CustomerId, product, request.Quantity);
        
        await _orderRepo.AddAsync(order);
        await _unitOfWork.SaveChangesAsync();
        
        _logger.LogInformation("Order {OrderId} created successfully", order.Id);
        return order;
    }
}

// 3. DOMAIN LAYER
public class Order {
    public Guid Id { get; private set; }
    public Guid CustomerId { get; private set; }
    public List<OrderItem> Items { get; private set; } = new();
    public decimal TotalAmount { get; private set; }
    public OrderStatus Status { get; private set; }
    public DateTime CreatedAt { get; private set; }
    
    private Order() { } // For EF Core
    
    public static Order Create(Guid customerId, Product product, int quantity) {
        // Business rule: Minimum order amount
        if (product.Price * quantity < 10) {
            throw new MinimumOrderAmountException("Order must be at least $10");
        }
        
        // Business rule: Stock validation
        if (!product.HasSufficientStock(quantity)) {
            throw new InsufficientStockException($"Only {product.StockQuantity} items available");
        }
        
        var order = new Order {
            Id = Guid.NewGuid(),
            CustomerId = customerId,
            Status = OrderStatus.Pending,
            CreatedAt = DateTime.UtcNow
        };
        
        order.AddItem(product, quantity);
        return order;
    }
    
    public void AddItem(Product product, int quantity) {
        var item = new OrderItem(product.Id, product.Price, quantity);
        Items.Add(item);
        RecalculateTotal();
    }
    
    private void RecalculateTotal() {
        TotalAmount = Items.Sum(item => item.Price * item.Quantity);
    }
}

// 4. INFRASTRUCTURE LAYER
public class OrderRepository : IOrderRepository {
    private readonly AppDbContext _context;
    
    public OrderRepository(AppDbContext context) {
        _context = context;
    }
    
    public async Task<Order?> GetByIdAsync(Guid id) {
        return await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task AddAsync(Order order) {
        await _context.Orders.AddAsync(order);
    }
}

public class AppDbContext : DbContext {
    public DbSet<Order> Orders { get; set; }
    public DbSet<Product> Products { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder) {
        modelBuilder.Entity<Order>()
            .HasMany(o => o.Items)
            .WithOne()
            .OnDelete(DeleteBehavior.Cascade);
    }
}</code></pre>
        
        <h4>Benefits & Trade-offs</h4>
        <div class="grid">
          <div>
            <h5>Benefits</h5>
            <ul>
              <li class="good"><strong>Clear Separation:</strong> Each layer has distinct responsibilities</li>
              <li class="good"><strong>Testability:</strong> Easy to test each layer in isolation</li>
              <li class="good"><strong>Maintainability:</strong> Changes in one layer don't affect others</li>
              <li class="good"><strong>Team Organization:</strong> Different teams can work on different layers</li>
              <li class="good"><strong>Technology Independence:</strong> Can change implementation of layers</li>
            </ul>
          </div>
          <div>
            <h5>Considerations</h5>
            <ul>
              <li class="warn"><strong>Performance:</strong> Multiple layers can add overhead</li>
              <li class="warn"><strong>Complexity:</strong> Can be overkill for simple applications</li>
              <li class="bad"><strong>Data Flow:</strong> Sometimes forces unnecessary data transformations</li>
              <li class="warn"><strong>Rigid Structure:</strong> Can be too restrictive for some scenarios</li>
            </ul>
          </div>
        </div>
        
        <h4>Common Variations</h4>
        <ul>
          <li><strong>3-Layer:</strong> Presentation, Business, Data Access (traditional enterprise)</li>
          <li><strong>5-Layer:</strong> Add Cross-cutting layer for logging, security, etc.</li>
          <li><strong>Onion/Clean Architecture:</strong> Invert dependencies to point inward to domain</li>
        </ul>
        
        <p class="note"><strong>Best Practice:</strong> Layered architecture works well as a starting point for most applications. As complexity grows, consider more sophisticated patterns like Hexagonal or Clean Architecture that provide better testability and flexibility.</p>
      </article>

      <article class="card topic" id="microservices" data-title="Microservices" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Microservices Architecture</h2></div>
        
        <h4>Key Concept</h4>
        <p>Microservices architecture is an approach where applications are built as a suite of small, independent services that communicate over well-defined APIs. Each service owns its data, runs in its own process, and can be developed, deployed, and scaled independently. This enables organizations to move faster and build more resilient systems.</p>
        
        <h4>Core Learning</h4>
        <p>Microservices are not just a technical pattern - they're an organizational one. They work best when you have mature teams, robust DevOps practices, and clear business domain boundaries. The goal is <strong>team autonomy</strong> and <strong>business agility</strong>, not just technical benefits. Each service should align with a bounded context from domain-driven design.</p>
        
        <h4>Key Principles</h4>
        <ul>
          <li><strong>Single Responsibility:</strong> Each service has one business responsibility</li>
          <li><strong>Autonomous:</strong> Services can be developed, deployed, and scaled independently</li>
          <li><strong>Decentralized:</strong> Each service manages its own data and business rules</li>
          <li><strong>Fault Tolerant:</strong> Services must handle failures gracefully</li>
          <li><strong>Observable:</strong> Comprehensive logging, monitoring, and tracing</li>
        </ul>
        
        <h4>Example Architecture</h4>
        <pre><button class="copy">Copy</button><code>// E-Commerce Microservices Example

┌───────────────────────────────────────────┐
│                 API Gateway                     │
├───────────────────────────────────────────┤
│ User Service  │ Catalog Service │ Order Service  │
│   - Auth      │   - Products    │   - Orders     │
│   - Profile   │   - Search      │   - Inventory   │
│   - UserDB    │   - CatalogDB   │   - OrderDB    │
├─────────────┼───────────────┼──────────────┤
│ Payment      │ Notification   │ Analytics     │
│ Service      │ Service        │ Service       │
│   - PaymentDB │   - Templates    │   - EventDB    │
└─────────────┴───────────────┴──────────────┘

              Message Bus (Kafka/RabbitMQ)

// Each service:
// - Has its own database
// - Can be developed by different teams
// - Scales independently
// - Uses different technologies if needed</code></pre>
        
        <h4>Service Communication Patterns</h4>
        <div class="grid">
          <div>
            <h5>Synchronous Communication</h5>
            <ul>
              <li><strong>REST APIs:</strong> HTTP-based, simple, widely supported</li>
              <li><strong>GraphQL:</strong> Flexible queries, reduces over-fetching</li>
              <li><strong>gRPC:</strong> High performance, type-safe, streaming support</li>
            </ul>
            
            <pre><button class="copy">Copy</button><code>// REST API Example
GET /api/orders/12345
Response: {
  "orderId": "12345",
  "customerId": "user-789",
  "items": [
    {
      "productId": "prod-456",
      "quantity": 2,
      "price": 29.99
    }
  ],
  "status": "confirmed"
}</code></pre>
          </div>
          
          <div>
            <h5>Asynchronous Communication</h5>
            <ul>
              <li><strong>Events:</strong> Domain events for business processes</li>
              <li><strong>Commands:</strong> Direct service-to-service actions</li>
              <li><strong>Message Queues:</strong> Reliable, decoupled communication</li>
            </ul>
            
            <pre><button class="copy">Copy</button><code>// Event-Driven Example
{
  "eventType": "OrderPlaced",
  "eventId": "evt-12345",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "orderId": "12345",
    "customerId": "user-789",
    "totalAmount": 59.98
  }
}

// Multiple services can react:
// - Inventory: Reserve items
// - Payment: Process payment
// - Notification: Send confirmation</code></pre>
          </div>
        </div>
        
        <h4>Data Management Strategies</h4>
        <ul>
          <li><strong>Database per Service:</strong> Each service owns its data - no shared databases</li>
          <li><strong>Saga Pattern:</strong> Manage distributed transactions across services</li>
          <li><strong>Event Sourcing:</strong> Store events instead of current state</li>
          <li><strong>CQRS:</strong> Separate read and write models</li>
          <li><strong>Data Synchronization:</strong> Eventually consistent through events</li>
        </ul>
        
        <h4>Implementation Example (Order Service in .NET)</h4>
        <pre><button class="copy">Copy</button><code>// Domain Event
public class OrderPlacedEvent : IDomainEvent {
    public Guid OrderId { get; set; }
    public Guid CustomerId { get; set; }
    public decimal TotalAmount { get; set; }
    public DateTime OccurredOn { get; set; } = DateTime.UtcNow;
}

// Order Service API
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase {
    private readonly IOrderService _orderService;
    private readonly IEventBus _eventBus;
    
    [HttpPost]
    public async Task<ActionResult<OrderDto>> CreateOrder([FromBody] CreateOrderCommand command) {
        try {
            var order = await _orderService.CreateOrderAsync(command);
            
            // Publish event for other services
            var orderEvent = new OrderPlacedEvent {
                OrderId = order.Id,
                CustomerId = order.CustomerId,
                TotalAmount = order.TotalAmount
            };
            
            await _eventBus.PublishAsync(orderEvent);
            
            return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order.ToDto());
        }
        catch (Exception ex) {
            // Log error and return appropriate response
            return BadRequest(new { error = ex.Message });
        }
    }
}

// Event Handler in Payment Service
public class OrderPlacedEventHandler : IEventHandler<OrderPlacedEvent> {
    private readonly IPaymentService _paymentService;
    private readonly ILogger<OrderPlacedEventHandler> _logger;
    
    public async Task HandleAsync(OrderPlacedEvent @event) {
        _logger.LogInformation("Processing payment for order {OrderId}", @event.OrderId);
        
        try {
            await _paymentService.ProcessPaymentAsync(
                @event.CustomerId, 
                @event.TotalAmount, 
                @event.OrderId);
                
            _logger.LogInformation("Payment processed for order {OrderId}", @event.OrderId);
        }
        catch (Exception ex) {
            _logger.LogError(ex, "Payment failed for order {OrderId}", @event.OrderId);
            
            // Publish compensation event
            await PublishPaymentFailedEventAsync(@event.OrderId);
        }
    }
}

// Service Configuration
public class Startup {
    public void ConfigureServices(IServiceCollection services) {
        // Database
        services.AddDbContext<OrderDbContext>(options =>
            options.UseSqlServer(connectionString));
            
        // Message Bus
        services.AddSingleton<IEventBus, KafkaEventBus>();
        
        // Circuit Breaker for external calls
        services.AddHttpClient<ICatalogService>()
            .AddPolicyHandler(GetRetryPolicy())
            .AddPolicyHandler(GetCircuitBreakerPolicy());
            
        // Health Checks
        services.AddHealthChecks()
            .AddDbContextCheck<OrderDbContext>()
            .AddCheck<KafkaHealthCheck>("kafka");
    }
    
    private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy() {
        return Policy.HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
            .WaitAndRetryAsync(3, retryAttempt => 
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
    }
}</code></pre>
        
        <h4>Essential Infrastructure</h4>
        <div class="grid">
          <div>
            <h5>DevOps Requirements</h5>
            <ul>
              <li class="good"><strong>CI/CD Pipelines:</strong> Automated build, test, deploy for each service</li>
              <li class="good"><strong>Containerization:</strong> Docker containers for consistent deployment</li>
              <li class="good"><strong>Orchestration:</strong> Kubernetes for service management</li>
              <li class="good"><strong>Service Mesh:</strong> Istio/Linkerd for service communication</li>
              <li class="good"><strong>Infrastructure as Code:</strong> Terraform/ARM templates</li>
            </ul>
          </div>
          <div>
            <h5>Observability Stack</h5>
            <ul>
              <li class="good"><strong>Distributed Tracing:</strong> Jaeger/Zipkin for request tracing</li>
              <li class="good"><strong>Centralized Logging:</strong> ELK Stack or Cloud logging</li>
              <li class="good"><strong>Metrics & Monitoring:</strong> Prometheus + Grafana</li>
              <li class="good"><strong>Health Checks:</strong> Service health endpoints</li>
              <li class="good"><strong>Alerting:</strong> PagerDuty/OpsGenie integration</li>
            </ul>
          </div>
        </div>
        
        <h4>Benefits & Challenges</h4>
        <div class="grid">
          <div>
            <h5>Benefits</h5>
            <ul>
              <li class="good"><strong>Team Autonomy:</strong> Teams can work independently</li>
              <li class="good"><strong>Technology Diversity:</strong> Use best tool for each service</li>
              <li class="good"><strong>Scalability:</strong> Scale services based on demand</li>
              <li class="good"><strong>Fault Isolation:</strong> Service failures don't cascade</li>
              <li class="good"><strong>Faster Deployment:</strong> Deploy services independently</li>
            </ul>
          </div>
          <div>
            <h5>Challenges</h5>
            <ul>
              <li class="bad"><strong>Distributed System Complexity:</strong> Network, latency, consistency issues</li>
              <li class="bad"><strong>Data Management:</strong> No ACID transactions across services</li>
              <li class="bad"><strong>Testing:</strong> Integration testing is much harder</li>
              <li class="warn"><strong>Operational Overhead:</strong> More services to monitor and maintain</li>
              <li class="warn"><strong>Service Dependencies:</strong> Complex service interactions</li>
            </ul>
          </div>
        </div>
        
        <h4>When to Use Microservices</h4>
        <ul>
          <li><strong>Large teams</strong> (>20 developers) with clear domain expertise</li>
          <li><strong>Mature DevOps practices</strong> with automated CI/CD and monitoring</li>
          <li><strong>Different scalability requirements</strong> for different parts of the system</li>
          <li><strong>Need for technology diversity</strong> or different release cycles</li>
          <li><strong>Well-understood domain boundaries</strong> from Domain-Driven Design</li>
        </ul>
        
        <p class="note"><strong>Conway's Law in Action:</strong> "Organizations design systems that mirror their communication structures." Microservices work best when your team structure aligns with your service boundaries. Start with clear team ownership and domain boundaries.</p>
      </article>

      <article class="card topic" id="eda" data-title="Event-Driven Architecture (EDA)" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Event‑Driven Architecture (EDA)</h2></div>
        <ul>
          <li>Loosely coupled via async events (Kafka, RabbitMQ).</li>
          <li>Improves throughput; eventual consistency trade‑offs.</li>
        </ul>
      </article>

      <article class="card topic" id="soa" data-title="Service-Oriented Architecture (SOA)" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Service‑Oriented Architecture (SOA)</h2></div>
        <p>Services communicate via enterprise bus or HTTP; often larger, reusable enterprise services.</p>
      </article>

      <article class="card topic" id="serverless" data-title="Serverless & Cloud-Native" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Serverless & Cloud‑Native</h2></div>
        <ul>
          <li>Managed compute (AWS Lambda/Azure Functions), autoscaling, pay‑per‑use.</li>
          <li>Design for statelessness, cold starts, idempotency, retries.</li>
        </ul>
      </article>

      <article class="card topic" id="hex-onion-clean" data-title="Hexagonal / Onion / Clean" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Hexagonal / Onion / Clean</h2></div>
        <p>Ports & Adapters; dependency rule points <em>inward</em> to the domain core. Infrastructure is a plugin.</p>
      </article>

      <article class="card topic" id="ddd" data-title="Domain-Driven Design (DDD)" data-category="Architecture Styles">
        <div class="title"><span class="tag">Style</span><h2>Domain‑Driven Design (DDD)</h2></div>
        <ul>
          <li>Ubiquitous language with domain experts.</li>
          <li>Entities, Value Objects, Aggregates (enforce invariants).</li>
          <li>Bounded contexts + context maps (upstream/downstream).</li>
        </ul>
      </article>

      <!-- ===== Cloud & Infra ===== -->
      <article class="card topic" id="cloud-platforms" data-title="Cloud Platforms (AWS/Azure/GCP)" data-category="Cloud & Infra">
        <div class="title"><span class="tag">Cloud</span><h2>Cloud Platforms: AWS, Azure, GCP — fundamentals</h2></div>
        <ul>
          <li>Core: compute, storage, networking, IAM, databases, messaging.</li>
          <li>Cost awareness: right‑size, autoscale, reserved instances.</li>
        </ul>
      </article>

      <article class="card topic" id="cloud-native" data-title="Cloud-Native Principles" data-category="Cloud & Infra">
        <div class="title"><span class="tag">Cloud</span><h2>Cloud‑Native Principles</h2></div>
        <ul>
          <li>Immutable infrastructure; declarative config; automate everything.</li>
          <li>12‑factor apps: stateless processes, externalize state & config.</li>
        </ul>
      </article>

      <article class="card topic" id="iac" data-title="Infrastructure as Code (Terraform/Ansible/Pulumi)" data-category="Cloud & Infra">
        <div class="title"><span class="tag">Cloud</span><h2>Infrastructure as Code (IaC)</h2></div>
        <pre><button class="copy">Copy</button><code># Terraform snippet (aws s3 bucket)
resource "aws_s3_bucket" "logs" { bucket = "my-logs" }
</code></pre>
        <p class="note">Version your infra like code; enable repeatable environments.</p>
      </article>

      <article class="card topic" id="containers" data-title="Containers & Orchestration (Docker/Kubernetes)" data-category="Cloud & Infra">
        <div class="title"><span class="tag">Cloud</span><h2>Containerization & Orchestration</h2></div>
        <ul>
          <li>Docker images define runtime; Kubernetes orchestrates scaling, rollout, healing.</li>
          <li>Use health probes, resource limits, and config/secret objects.</li>
        </ul>
      </article>

      <article class="card topic" id="cicd" data-title="CI/CD (Actions/GitLab/Jenkins/ArgoCD)" data-category="Cloud & Infra">
        <div class="title"><span class="tag">Cloud</span><h2>CI/CD Pipelines</h2></div>
        <pre><button class="copy">Copy</button><code># GitHub Actions: build-and-test
name: ci
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-dotnet@v4
      with: { dotnet-version: '8.0.x' }
    - run: dotnet test --configuration Release</code></pre>
      </article>

      <!-- ===== Scalability / Performance / Reliability ===== -->
      <article class="card topic" id="caching" data-title="Caching strategies (Redis etc.)" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Scalability</span><h2>Caching Strategies</h2></div>
        
        <h4>Key Concept</h4>
        <p>Caching is a technique for storing frequently accessed data in a faster storage layer to reduce access time and database load. It's one of the most effective ways to improve system performance and scalability. The key is choosing the right caching strategy, location, and invalidation approach for your use case.</p>
        
        <h4>Core Learning</h4>
        <p>Caching works on the principle of <strong>locality of reference</strong> - recently accessed data is likely to be accessed again soon. However, caching introduces complexity around data consistency and cache invalidation. As Phil Karlton said: "There are only two hard things in Computer Science: cache invalidation and naming things."</p>
        
        <h4>Types of Caching</h4>
        <div class="grid">
          <div>
            <h5>By Location</h5>
            <ul>
              <li><strong>Browser Cache:</strong> Client-side caching of static assets</li>
              <li><strong>CDN Cache:</strong> Geographic distribution of static content</li>
              <li><strong>Reverse Proxy:</strong> Nginx/Varnish for full page caching</li>
              <li><strong>Application Cache:</strong> In-process memory caching</li>
              <li><strong>Distributed Cache:</strong> Redis/Memcached across servers</li>
              <li><strong>Database Cache:</strong> Query result caching in DBMS</li>
            </ul>
          </div>
          <div>
            <h5>By Data Type</h5>
            <ul>
              <li><strong>Page/Fragment Cache:</strong> Complete HTML responses</li>
              <li><strong>Object Cache:</strong> Serialized business objects</li>
              <li><strong>Query Cache:</strong> Database query results</li>
              <li><strong>Computed Cache:</strong> Expensive calculation results</li>
              <li><strong>Session Cache:</strong> User session data</li>
            </ul>
          </div>
        </div>
        
        <h4>Caching Patterns</h4>
        
        <h5>1. Cache-Aside (Lazy Loading)</h5>
        <pre><button class="copy">Copy</button><code>// Cache-Aside Pattern in C# with Redis
public class ProductService {
    private readonly IDatabase _cache;
    private readonly IProductRepository _repository;
    
    public ProductService(IDatabase cache, IProductRepository repository) {
        _cache = cache;
        _repository = repository;
    }
    
    public async Task<Product> GetProductAsync(int productId) {
        string cacheKey = $"product:{productId}";
        
        // 1. Try to get from cache first
        var cached = await _cache.StringGetAsync(cacheKey);
        if (cached.HasValue) {
            return JsonSerializer.Deserialize<Product>(cached);
        }
        
        // 2. Cache miss - load from database
        var product = await _repository.GetByIdAsync(productId);
        if (product != null) {
            // 3. Store in cache for future requests
            var serialized = JsonSerializer.Serialize(product);
            await _cache.StringSetAsync(cacheKey, serialized, TimeSpan.FromMinutes(15));
        }
        
        return product;
    }
    
    public async Task UpdateProductAsync(Product product) {
        // Update database
        await _repository.UpdateAsync(product);
        
        // Invalidate cache
        string cacheKey = $"product:{product.Id}";
        await _cache.KeyDeleteAsync(cacheKey);
    }
}</code></pre>
        
        <h5>2. Write-Through Cache</h5>
        <pre><button class="copy">Copy</button><code>// Write-Through: Write to cache and database simultaneously
public async Task UpdateProductAsync(Product product) {
    // Write to database first
    await _repository.UpdateAsync(product);
    
    // Update cache
    string cacheKey = $"product:{product.Id}";
    var serialized = JsonSerializer.Serialize(product);
    await _cache.StringSetAsync(cacheKey, serialized, TimeSpan.FromMinutes(15));
}</code></pre>
        
        <h5>3. Write-Behind (Write-Back) Cache</h5>
        <pre><button class="copy">Copy</button><code>// Write-Behind: Write to cache immediately, database asynchronously
public async Task UpdateProductAsync(Product product) {
    // Write to cache immediately
    string cacheKey = $"product:{product.Id}";
    var serialized = JsonSerializer.Serialize(product);
    await _cache.StringSetAsync(cacheKey, serialized, TimeSpan.FromMinutes(15));
    
    // Queue for background database update
    await _backgroundTaskQueue.QueueBackgroundWorkItemAsync(async token => {
        await _repository.UpdateAsync(product);
    });
}</code></pre>
        
        <h4>Advanced Caching Techniques</h4>
        
        <h5>Cache Warming</h5>
        <pre><button class="copy">Copy</button><code>// Pre-populate cache with frequently accessed data
public class CacheWarmupService : IHostedService {
    private readonly IProductService _productService;
    private readonly ILogger<CacheWarmupService> _logger;
    
    public async Task StartAsync(CancellationToken cancellationToken) {
        _logger.LogInformation("Starting cache warmup...");
        
        // Load top 100 most popular products into cache
        var popularProducts = await _productRepository.GetMostPopularAsync(100);
        
        foreach (var product in popularProducts) {
            await _productService.GetProductAsync(product.Id); // This will cache it
        }
        
        _logger.LogInformation("Cache warmup completed");
    }
}</code></pre>
        
        <h5>Cache Stampede Protection</h5>
        <pre><button class="copy">Copy</button><code>// Prevent multiple threads from loading same data simultaneously
public class ProductService {
    private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
    private readonly MemoryCache _localCache = new MemoryCache(new MemoryCacheOptions());
    
    public async Task<Product> GetProductAsync(int productId) {
        string cacheKey = $"product:{productId}";
        
        // Check local cache first (fastest)
        if (_localCache.TryGetValue(cacheKey, out Product cachedProduct)) {
            return cachedProduct;
        }
        
        // Use semaphore to prevent cache stampede
        await _semaphore.WaitAsync();
        try {
            // Double-check after acquiring lock
            if (_localCache.TryGetValue(cacheKey, out cachedProduct)) {
                return cachedProduct;
            }
            
            // Load from distributed cache or database
            var product = await LoadProductAsync(productId);
            
            // Cache locally for 5 minutes
            _localCache.Set(cacheKey, product, TimeSpan.FromMinutes(5));
            
            return product;
        }
        finally {
            _semaphore.Release();
        }
    }
}</code></pre>
        
        <h4>HTTP Caching</h4>
        <pre><button class="copy">Copy</button><code>// HTTP caching headers in ASP.NET Core
[HttpGet("{id}")]
[ResponseCache(Duration = 300)] // 5 minutes
public async Task<ActionResult<ProductDto>> GetProduct(int id) {
    var product = await _productService.GetProductAsync(id);
    if (product == null) {
        return NotFound();
    }
    
    // Set ETag for conditional requests
    var etag = GenerateETag(product);
    Response.Headers.ETag = etag;
    
    // Check if client has current version
    if (Request.Headers.IfNoneMatch.Contains(etag)) {
        return StatusCode(304); // Not Modified
    }
    
    return Ok(product.ToDto());
}

// Vary cache by user for personalized content
[ResponseCache(Duration = 60, VaryByHeader = "Authorization")]
public async Task<ActionResult> GetUserDashboard() {
    // Cached per user for 1 minute
    var userId = GetCurrentUserId();
    var dashboard = await _dashboardService.GetUserDashboardAsync(userId);
    return Ok(dashboard);
}</code></pre>
        
        <h4>Cache Configuration & Monitoring</h4>
        <pre><button class="copy">Copy</button><code>// Redis configuration with monitoring
services.AddStackExchangeRedisCache(options => {
    options.Configuration = "localhost:6379";
    options.ConfigurationOptions = new ConfigurationOptions {
        EndPoints = { "localhost:6379" },
        AbortOnConnectFail = false,
        ConnectRetry = 3,
        ConnectTimeout = 5000,
        SyncTimeout = 5000,
        AsyncTimeout = 5000
    };
});

// Cache metrics and monitoring
public class CacheMetrics {
    private readonly IMetrics _metrics;
    
    public void RecordCacheHit(string cacheType) {
        _metrics.IncrementCounter("cache.hits", new[] { ("type", cacheType) });
    }
    
    public void RecordCacheMiss(string cacheType) {
        _metrics.IncrementCounter("cache.misses", new[] { ("type", cacheType) });
    }
    
    public void RecordCacheLatency(string cacheType, TimeSpan duration) {
        _metrics.RecordHistogram("cache.latency", duration.TotalMilliseconds, 
            new[] { ("type", cacheType) });
    }
}</code></pre>
        
        <h4>Cache Invalidation Strategies</h4>
        <div class="grid">
          <div>
            <h5>Time-Based (TTL)</h5>
            <ul>
              <li class="good"><strong>Simple:</strong> Set expiration time</li>
              <li class="warn"><strong>Approximate:</strong> May serve stale data</li>
              <li><strong>Use for:</strong> Relatively static data</li>
            </ul>
          </div>
          <div>
            <h5>Event-Based</h5>
            <ul>
              <li class="good"><strong>Accurate:</strong> Invalidate on data changes</li>
              <li class="bad"><strong>Complex:</strong> Need to track dependencies</li>
              <li><strong>Use for:</strong> Critical data consistency</li>
            </ul>
          </div>
        </div>
        
        <h4>Best Practices</h4>
        <ul>
          <li><strong>Cache High-Read, Low-Write Data:</strong> Best ROI for caching effort</li>
          <li><strong>Use Cache Keys Wisely:</strong> Include version/timestamp in keys</li>
          <li><strong>Monitor Cache Hit Ratios:</strong> Aim for 80%+ hit ratio</li>
          <li><strong>Set Appropriate TTLs:</strong> Balance freshness vs performance</li>
          <li><strong>Handle Cache Failures Gracefully:</strong> Always have a fallback</li>
          <li><strong>Use Compression:</strong> For large objects in distributed cache</li>
        </ul>
        
        <h4>Common Anti-patterns</h4>
        <ul>
          <li class="bad"><strong>Cache Everything:</strong> Wastes memory and complicates invalidation</li>
          <li class="bad"><strong>Infinite TTLs:</strong> Leads to stale data</li>
          <li class="bad"><strong>Synchronous Cache Population:</strong> Blocks user requests</li>
          <li class="bad"><strong>No Monitoring:</strong> Can't optimize without metrics</li>
        </ul>
        
        <p class="note"><strong>Performance Tip:</strong> Use multi-level caching (L1: in-process, L2: distributed) for optimal performance. Local cache provides nanosecond access, while distributed cache provides consistency across instances.</p>
      </article>

      <article class="card topic" id="load-balancing" data-title="Load balancing & traffic management" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Scalability</span><h2>Load Balancing & Traffic Management</h2></div>
        
        <h4>Key Concept</h4>
        <p>Load balancing distributes incoming requests across multiple servers to optimize resource utilization, maximize throughput, minimize response time, and avoid overload. It's essential for building scalable and highly available systems that can handle traffic spikes and server failures gracefully.</p>
        
        <h4>Core Learning</h4>
        <p>Load balancers work at different layers of the network stack and use various algorithms to distribute traffic. The choice depends on your application characteristics, traffic patterns, and availability requirements. Modern load balancers also provide traffic management features like SSL termination, request routing, and health checks.</p>
        
        <h4>Types of Load Balancers</h4>
        <div class="grid">
          <div>
            <h5>Layer 4 (Transport) Load Balancer</h5>
            <ul>
              <li><strong>Works at:</strong> TCP/UDP level</li>
              <li><strong>Routes by:</strong> IP address and port</li>
              <li><strong>Pros:</strong> Fast, low latency, protocol agnostic</li>
              <li><strong>Cons:</strong> No application-level intelligence</li>
              <li><strong>Examples:</strong> AWS NLB, HAProxy (TCP mode)</li>
            </ul>
          </div>
          <div>
            <h5>Layer 7 (Application) Load Balancer</h5>
            <ul>
              <li><strong>Works at:</strong> HTTP/HTTPS level</li>
              <li><strong>Routes by:</strong> URL, headers, cookies, content</li>
              <li><strong>Pros:</strong> Smart routing, SSL termination, caching</li>
              <li><strong>Cons:</strong> Higher latency, more CPU intensive</li>
              <li><strong>Examples:</strong> AWS ALB, Nginx, Envoy, Traefik</li>
            </ul>
          </div>
        </div>
        
        <h4>Load Balancing Algorithms</h4>
        <pre><button class="copy">Copy</button><code>// Common Load Balancing Algorithms

1. Round Robin
   Request 1 → Server A
   Request 2 → Server B  
   Request 3 → Server C
   Request 4 → Server A (cycle repeats)

2. Weighted Round Robin
   Server A (weight: 3) gets 3 requests
   Server B (weight: 2) gets 2 requests  
   Server C (weight: 1) gets 1 request

3. Least Connections
   Route to server with fewest active connections
   
4. Least Response Time
   Route to server with fastest average response
   
5. IP Hash / Sticky Sessions
   hash(client_ip) % server_count
   Ensures same client always goes to same server
   
6. Resource Based
   Route based on CPU, memory, or custom metrics</code></pre>
        
        <h4>Nginx Load Balancer Configuration</h4>
        <pre><button class="copy">Copy</button><code># /etc/nginx/nginx.conf
upstream backend_servers {
    # Health check
    server 10.0.1.10:8080 weight=3 max_fails=3 fail_timeout=30s;
    server 10.0.1.11:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 10.0.1.12:8080 weight=1 max_fails=3 fail_timeout=30s;
    
    # Session persistence (optional)
    # ip_hash;
    
    # Least connections
    least_conn;
}

server {
    listen 80;
    server_name myapp.com;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    
    location / {
        # Apply rate limit
        limit_req zone=api burst=20 nodelay;
        
        # Proxy settings
        proxy_pass http://backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts
        proxy_connect_timeout 5s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Connection pooling
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "OK";
    }
}</code></pre>
        
        <h4>Advanced Traffic Management</h4>
        
        <h5>Blue-Green Deployment</h5>
        <pre><button class="copy">Copy</button><code># Blue-Green deployment with Nginx
upstream blue_env {
    server 10.0.1.10:8080;
    server 10.0.1.11:8080;
}

upstream green_env {
    server 10.0.2.10:8080;
    server 10.0.2.11:8080;
}

server {
    listen 80;
    server_name myapp.com;
    
    location / {
        # Switch traffic by changing this line
        proxy_pass http://blue_env;  # or http://green_env
        
        # Health check both environments
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        proxy_set_header Host $host;
    }
}</code></pre>
        
        <h5>Canary Releases</h5>
        <pre><button class="copy">Copy</button><code># Canary deployment: 90% to stable, 10% to canary
upstream stable {
    server 10.0.1.10:8080;
    server 10.0.1.11:8080;
}

upstream canary {
    server 10.0.2.10:8080;
}

server {
    listen 80;
    server_name myapp.com;
    
    location / {
        # Use split_clients for percentage-based routing
        set $upstream stable;
        if ($cookie_canary = "true") {
            set $upstream canary;
        }
        # 10% random traffic to canary
        if ($request_id ~ "^[0-9]$") {
            set $upstream canary;
        }
        
        proxy_pass http://$upstream;
        proxy_set_header Host $host;
    }
}</code></pre>
        
        <h4>Circuit Breaker Pattern</h4>
        <pre><button class="copy">Copy</button><code>// Circuit Breaker with Polly in C#
using Polly;
using Polly.CircuitBreaker;

public class ExternalApiService {
    private readonly HttpClient _httpClient;
    private readonly IAsyncPolicy<HttpResponseMessage> _circuitBreakerPolicy;
    
    public ExternalApiService(HttpClient httpClient) {
        _httpClient = httpClient;
        
        // Circuit breaker configuration
        _circuitBreakerPolicy = Policy
            .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
            .Or<HttpRequestException>()
            .CircuitBreakerAsync(
                handledEventsAllowedBeforeBreaking: 5,  // Fail 5 times
                durationOfBreak: TimeSpan.FromMinutes(1), // Stay open for 1 minute
                onBreak: (exception, duration) => {
                    Console.WriteLine($"Circuit breaker opened for {duration}");
                },
                onReset: () => {
                    Console.WriteLine("Circuit breaker reset");
                });
    }
    
    public async Task<ApiResponse> CallExternalApiAsync(string endpoint) {
        try {
            var response = await _circuitBreakerPolicy.ExecuteAsync(async () => {
                return await _httpClient.GetAsync(endpoint);
            });
            
            var content = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<ApiResponse>(content);
        }
        catch (CircuitBreakerOpenException) {
            // Return cached data or default response
            return await GetFallbackResponseAsync();
        }
    }
}</code></pre>
        
        <h4>Rate Limiting Strategies</h4>
        <div class="grid">
          <div>
            <h5>Token Bucket</h5>
            <pre><button class="copy">Copy</button><code>public class TokenBucketRateLimiter {
    private readonly int _capacity;
    private readonly int _refillRate;
    private int _tokens;
    private DateTime _lastRefill;
    private readonly object _lock = new object();
    
    public TokenBucketRateLimiter(int capacity, int refillRate) {
        _capacity = capacity;
        _refillRate = refillRate;
        _tokens = capacity;
        _lastRefill = DateTime.UtcNow;
    }
    
    public bool TryConsume(int tokensRequired = 1) {
        lock (_lock) {
            RefillTokens();
            
            if (_tokens >= tokensRequired) {
                _tokens -= tokensRequired;
                return true;
            }
            return false;
        }
    }
    
    private void RefillTokens() {
        var now = DateTime.UtcNow;
        var elapsed = now - _lastRefill;
        var tokensToAdd = (int)(elapsed.TotalSeconds * _refillRate);
        
        if (tokensToAdd > 0) {
            _tokens = Math.Min(_capacity, _tokens + tokensToAdd);
            _lastRefill = now;
        }
    }
}</code></pre>
          </div>
          <div>
            <h5>Sliding Window</h5>
            <pre><button class="copy">Copy</button><code>public class SlidingWindowRateLimiter {
    private readonly int _maxRequests;
    private readonly TimeSpan _windowSize;
    private readonly Queue<DateTime> _requests;
    private readonly object _lock = new object();
    
    public SlidingWindowRateLimiter(int maxRequests, TimeSpan windowSize) {
        _maxRequests = maxRequests;
        _windowSize = windowSize;
        _requests = new Queue<DateTime>();
    }
    
    public bool TryAcquire() {
        lock (_lock) {
            var now = DateTime.UtcNow;
            var cutoff = now - _windowSize;
            
            // Remove old requests
            while (_requests.Count > 0 && _requests.Peek() < cutoff) {
                _requests.Dequeue();
            }
            
            if (_requests.Count < _maxRequests) {
                _requests.Enqueue(now);
                return true;
            }
            return false;
        }
    }
}</code></pre>
          </div>
        </div>
        
        <h4>Health Checks</h4>
        <pre><button class="copy">Copy</button><code>// ASP.NET Core health checks
public class Startup {
    public void ConfigureServices(IServiceCollection services) {
        services.AddHealthChecks()
            .AddCheck("database", new DatabaseHealthCheck())
            .AddCheck("external-api", new ExternalApiHealthCheck())
            .AddCheck("memory", () => {
                var allocated = GC.GetTotalMemory(forceFullCollection: false);
                var threshold = 1024 * 1024 * 1024; // 1GB
                return allocated < threshold ? 
                    HealthCheckResult.Healthy() : 
                    HealthCheckResult.Unhealthy($"Memory usage: {allocated}");
            });
    }
    
    public void Configure(IApplicationBuilder app) {
        app.UseHealthChecks("/health", new HealthCheckOptions {
            ResponseWriter = async (context, report) => {
                context.Response.ContentType = "application/json";
                var response = new {
                    status = report.Status.ToString(),
                    checks = report.Entries.Select(x => new {
                        name = x.Key,
                        status = x.Value.Status.ToString(),
                        exception = x.Value.Exception?.Message,
                        duration = x.Value.Duration.ToString()
                    })
                };
                await context.Response.WriteAsync(JsonSerializer.Serialize(response));
            }
        });
    }
}</code></pre>
        
        <h4>Best Practices</h4>
        <ul>
          <li><strong>Use Health Checks:</strong> Remove unhealthy servers from rotation automatically</li>
          <li><strong>Implement Graceful Degradation:</strong> Serve cached/simplified responses when backends fail</li>
          <li><strong>Monitor Metrics:</strong> Track response times, error rates, connection counts</li>
          <li><strong>SSL Termination:</strong> Offload SSL processing to load balancer</li>
          <li><strong>Connection Pooling:</strong> Reuse connections to reduce overhead</li>
          <li><strong>Sticky Sessions When Needed:</strong> But prefer stateless applications</li>
        </ul>
        
        <p class="note"><strong>Cloud Native Tip:</strong> Modern service meshes like Istio provide advanced traffic management features including retries, timeouts, circuit breakers, and observability out of the box.</p>
      </article>

      <article class="card topic" id="db-scaling" data-title="Database scaling: Sharding/Replication/Partitioning" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Scalability</span><h2>Database Scaling</h2></div>
        <ul>
          <li><strong>Vertical</strong> first (indexes, query plans); then <strong>replication/partitioning</strong>.</li>
          <li>Sharding keys must reflect access patterns; avoid cross‑shard joins.</li>
        </ul>
      </article>

      <article class="card topic" id="messaging" data-title="Message queues & streaming (Kafka/RabbitMQ/SQS)" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Scalability</span><h2>Message Queues & Streaming</h2></div>
        <ul>
          <li>Queues for work distribution/retries; streams for ordered logs & analytics.</li>
          <li>Guarantees: at‑least‑once, exactly‑once (effective), ordering, idempotency.</li>
        </ul>
      </article>

      <article class="card topic" id="observability" data-title="Monitoring & observability (Prometheus/Grafana/ELK)" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Reliability</span><h2>Monitoring & Observability</h2></div>
        <ul>
          <li>Logs, metrics, traces: correlate with a request ID.</li>
          <li>SLOs & SLIs; alert on symptoms (error rate, latency), not just causes.</li>
        </ul>
      </article>

      <article class="card topic" id="ha-dr" data-title="High availability & disaster recovery" data-category="Scalability & Reliability">
        <div class="title"><span class="tag">Reliability</span><h2>High Availability & Disaster Recovery</h2></div>
        <ul>
          <li>Multi‑AZ/region replicas; automated failover; RPO/RTO objectives.</li>
          <li>Run game days & restore drills; document recovery runbooks.</li>
        </ul>
      </article>

      <!-- ===== Security & Compliance ===== -->
      <article class="card topic" id="auth" data-title="Authentication & Authorization (OAuth2/JWT/OIDC)" data-category="Security">
        <div class="title"><span class="tag">Security</span><h2>Authentication & Authorization</h2></div>
        <ul>
          <li>Use OAuth2/OIDC with an IdP (Auth0/Azure AD/Keycloak).</li>
          <li>Prefer short‑lived tokens, refresh tokens, and scopes/roles.</li>
        </ul>
      </article>

      <article class="card topic" id="secure-design" data-title="Secure design (least privilege, zero trust)" data-category="Security">
        <div class="title"><span class="tag">Security</span><h2>Secure Design Principles</h2></div>
        <ul>
          <li>Least privilege; defense in depth; fail secure.</li>
          <li>Zero trust: verify explicitly; assume breach.</li>
        </ul>
      </article>

      <article class="card topic" id="encryption" data-title="Data encryption (in transit & at rest)" data-category="Security">
        <div class="title"><span class="tag">Security</span><h2>Data Encryption</h2></div>
        <ul>
          <li>TLS 1.2+ for data in transit; rotate certs/keys; pin when needed.</li>
          <li>At rest: KMS/CMK; separate duties; audit access.</li>
        </ul>
      </article>

      <article class="card topic" id="owasp" data-title="OWASP Top 10" data-category="Security">
        <div class="title"><span class="tag">Security</span><h2>OWASP Top 10 (Web Risks)</h2></div>
        <ul>
          <li>Broken access control, injections, cryptographic failures, etc.</li>
          <li>Threat modeling + SAST/DAST + dependency scanning in CI.</li>
        </ul>
      </article>

      <article class="card topic" id="compliance" data-title="Regulatory compliance (GDPR/HIPAA/PCI-DSS)" data-category="Security">
        <div class="title"><span class="tag">Security</span><h2>Regulatory Compliance</h2></div>
        <p>Map data flows, define lawful bases, minimize PII, maintain records of processing, and document DPIAs where required.</p>
      </article>

      <!-- ===== Data & Storage ===== -->
      <article class="card topic" id="relational" data-title="Relational DBs (SQL)" data-category="Data & Storage">
        <div class="title"><span class="tag">Data</span><h2>Relational Databases (SQL)</h2></div>
        <ul>
          <li>Normalize to reduce anomalies; denormalize for reads when profiling proves it.</li>
          <li>Indexes, transactions (ACID), and isolation levels matter.</li>
        </ul>
      </article>

      <article class="card topic" id="nosql" data-title="NoSQL (Mongo/Dynamo/Cassandra) — when to use" data-category="Data & Storage">
        <div class="title"><span class="tag">Data</span><h2>NoSQL Databases — when to use</h2></div>
        <ul>
          <li>Document (MongoDB): flexible schemas, content/catalog.</li>
          <li>Key‑value (DynamoDB/Redis): ultra‑fast lookups.</li>
          <li>Wide‑column (Cassandra): high write throughput, time‑series.</li>
        </ul>
      </article>

      <article class="card topic" id="cap" data-title="CAP Theorem & trade-offs" data-category="Data & Storage">
        <div class="title"><span class="tag">Data</span><h2>CAP Theorem & Trade‑offs</h2></div>
        <p>In a partition, choose between <strong>consistency</strong> and <strong>availability</strong>. Design for what your users value most.</p>
      </article>

      <article class="card topic" id="es-cqrs" data-title="Event sourcing & CQRS (data view)" data-category="Data & Storage">
        <div class="title"><span class="tag">Data</span><h2>Event Sourcing & CQRS (Data View)</h2></div>
        <p>Persist events; build read models tailored for queries. Great for audit trails and complex workflows.</p>
      </article>

      <article class="card topic" id="dwh" data-title="Data lakes, warehouses, pipelines (ETL/ELT)" data-category="Data & Storage">
        <div class="title"><span class="tag">Data</span><h2>Data Lakes, Warehouses, Pipelines</h2></div>
        <ul>
          <li>ELT on cloud warehouses (BigQuery/Snowflake) vs ETL to on‑prem.</li>
          <li>Ingest (Kafka Connect), transform (dbt/Spark), catalog & govern (Glue).</li>
        </ul>
      </article>

      <!-- ===== Systems Thinking & Trade-offs ===== -->
      <article class="card topic" id="nfrs" data-title="Non-functional requirements (NFRs)" data-category="Systems & Trade‑offs">
        <div class="title"><span class="tag">Systems</span><h2>Non‑Functional Requirements (NFRs)</h2></div>
        <ul>
          <li>Scalability, Reliability, Maintainability, Portability, Usability, Performance.</li>
          <li>Turn into <strong>measurable</strong> SLIs/SLOs (e.g., p95 latency &lt; 250ms).</li>
        </ul>
      </article>

      <article class="card topic" id="tradeoffs" data-title="Trade-off analysis" data-category="Systems & Trade‑offs">
        <div class="title"><span class="tag">Systems</span><h2>Trade‑off Analysis</h2></div>
        <ul>
          <li>Latency vs throughput, consistency vs availability, coupling vs cohesion.</li>
          <li>Use scorecards & RFCs; record decisions in ADRs.</li>
        </ul>
      </article>

      <article class="card topic" id="adr" data-title="Architecture Decision Records (ADR)" data-category="Systems & Trade‑offs">
        <div class="title"><span class="tag">Systems</span><h2>Architecture Decision Records (ADR)</h2></div>
        <pre><button class="copy">Copy</button><code># ADR-0007: Adopt Redis Cache
Context: Home page latency too high at peak.
Decision: Use Redis with cache-aside (10 min TTL).
Consequences: +Faster reads; -Need invalidation on updates.
Status: Accepted (2025-08-19)</code></pre>
      </article>

      <!-- ===== Soft Skills & Leadership ===== -->
      <article class="card topic" id="soft-skills" data-title="Soft Skills & Leadership (overview)" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Soft Skills & Leadership</h2></div>
        <ul>
          <li>Translate business goals into technical roadmaps.</li>
          <li>Mentor engineers; set engineering standards; foster feedback culture.</li>
        </ul>
      </article>

      <article class="card topic" id="communication" data-title="Communication with stakeholders" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Communication with Stakeholders</h2></div>
        <ul>
          <li>Use the C4 model diagrams; avoid jargon; highlight risks & costs.</li>
          <li>Provide options A/B/C with trade‑offs and recommendation.</li>
        </ul>
      </article>

      <article class="card topic" id="mentoring" data-title="Mentoring & guiding teams" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Mentoring & Guiding Teams</h2></div>
        <ul>
          <li>Pair design reviews with concrete code examples.</li>
          <li>Create learning paths; celebrate small wins.</li>
        </ul>
      </article>

      <article class="card topic" id="negotiation" data-title="Negotiation & explaining trade-offs" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Negotiation & Trade‑offs</h2></div>
        <ul>
          <li>Time/Scope/Quality triangle; agree on what moves.</li>
          <li>Seek win‑win; quantify impact with data.</li>
        </ul>
      </article>

      <article class="card topic" id="docs-diagrams" data-title="Technical docs & diagrams" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Technical Documentation & Diagrams</h2></div>
        <pre><button class="copy">Copy</button><code>%% Mermaid: C4-ish system context
flowchart LR
  user[User] --> web[Web App]
  web --> api[API]
  api --> db[(DB)]
</code></pre>
      </article>

      <article class="card topic" id="biz-alignment" data-title="Aligning architecture with business goals" data-category="Soft Skills">
        <div class="title"><span class="tag">People</span><h2>Aligning with Business Goals</h2></div>
        <p>Every architecture choice should trace to a measurable business outcome (revenue, retention, risk).</p>
      </article>

      <!-- ===== Practical Tools ===== -->
      <article class="card topic" id="diagramming" data-title="Diagramming & Modeling (C4/UML/PlantUML/Mermaid)" data-category="Tools">
        <div class="title"><span class="tag">Tools</span><h2>Diagramming & Modeling</h2></div>
        <ul>
          <li><strong>C4</strong> for context/container/component; <strong>UML</strong> for sequence/state.</li>
          <li><strong>PlantUML/Mermaid</strong> keep diagrams in version control.</li>
        </ul>
      </article>

      <article class="card topic" id="agile" data-title="Project Management (Scrum/Kanban/SAFe)" data-category="Tools">
        <div class="title"><span class="tag">Tools</span><h2>Project Management & Agile</h2></div>
        <ul>
          <li>Scrum for iterative delivery; Kanban for flow; SAFe for large programs.</li>
        </ul>
      </article>

      <article class="card topic" id="collab" data-title="Collaboration tools (Jira/Confluence/Miro/Notion)" data-category="Tools">
        <div class="title"><span class="tag">Tools</span><h2>Collaboration Tools</h2></div>
        <ul>
          <li>Jira (tracking), Confluence/Notion (docs), Miro (workshops), RFCs for proposals.</li>
        </ul>
      </article>

      <!-- ===== Roadmap ===== -->
      <article class="card topic" id="roadmap" data-title="Roadmap: Senior Dev → Architect" data-category="Roadmap">
        <div class="title"><span class="tag">Roadmap</span><h2>Roadmap Approach</h2></div>
        <ol>
          <li><strong>Master principles</strong>: SOLID/DRY/KISS/YAGNI, SoC, DI.</li>
          <li><strong>Learn styles</strong>: layered → hexagonal; understand monolith vs microservices.</li>
          <li><strong>Scale</strong>: caching, queues, observability, HA/DR.</li>
          <li><strong>Cloud</strong>: containers, Kubernetes, IaC, CI/CD.</li>
          <li><strong>Data</strong>: SQL/NoSQL, CAP, warehousing, ES/CQRS.</li>
          <li><strong>Security</strong>: authn/z, OWASP, encryption, compliance basics.</li>
          <li><strong>Lead</strong>: docs, ADRs, mentoring, stakeholder comms.</li>
        </ol>
      </article>

      <div class="footer">Made as a single self‑contained page. No external deps. © 2025</div>
    </section>
  </main>

  <script>
    // --- Utilities ---
    const $ = (sel, ctx=document) => ctx.querySelector(sel);
    const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));

    // Mobile responsive state
    let isMobileView = () => window.innerWidth < 980;
    let isTabletView = () => window.innerWidth >= 768 && window.innerWidth < 980;
    
    // Attach copy buttons to code blocks
    function attachCopy(){
      $$("pre").forEach(pre => {
        const btn = pre.querySelector('.copy');
        if(!btn) return;
        btn.addEventListener('click', async () => {
          const code = pre.querySelector('code').innerText;
          try{ 
            await navigator.clipboard.writeText(code); 
            btn.textContent='Copied!'; 
            setTimeout(()=>btn.textContent='Copy',1200);
          }catch{
            btn.textContent='Error';
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = code;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            setTimeout(()=>btn.textContent='Copy',1200);
          }
        });
      });
    }

    // Mobile menu toggle
    function initMobileMenu() {
      const mobileToggle = $('#mobileMenuToggle');
      const filtersMenu = $('#filtersMenu');
      
      if (mobileToggle && filtersMenu) {
        mobileToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          filtersMenu.classList.toggle('hidden');
        });
        
        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!filtersMenu.contains(e.target) && !mobileToggle.contains(e.target)) {
            filtersMenu.classList.add('hidden');
          }
        });
      }
    }
    
    // Mobile sidebar toggle
    function initMobileSidebar() {
      const sidebarToggle = $('#sidebarToggle');
      const sidebarContent = $('#sidebarContent');
      
      if (sidebarToggle && sidebarContent) {
        sidebarToggle.addEventListener('click', () => {
          const isActive = sidebarContent.classList.contains('active');
          sidebarContent.classList.toggle('active', !isActive);
          sidebarToggle.classList.toggle('active', !isActive);
        });
        
        // Auto-expand on desktop
        function handleResize() {
          if (!isMobileView()) {
            sidebarContent.classList.add('active');
            sidebarToggle.classList.add('active');
          } else {
            sidebarContent.classList.remove('active');
            sidebarToggle.classList.remove('active');
          }
        }
        
        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call
      }
    }
    
    // Responsive filters visibility
    function handleResponsiveFilters() {
      const filtersMenu = $('#filtersMenu');
      
      function updateFiltersVisibility() {
        if (isMobileView()) {
          // On mobile, hide filters by default
          filtersMenu.classList.add('hidden');
        } else {
          // On desktop/tablet, always show filters
          filtersMenu.classList.remove('hidden');
        }
      }
      
      window.addEventListener('resize', updateFiltersVisibility);
      updateFiltersVisibility(); // Initial call
    }

    // Build topic buttons from articles
    function buildNav(){
      const topics = $$(".topic").map(a => ({ id:a.id, title:a.dataset.title, category:a.dataset.category }));
      // Sort by category then title
      topics.sort((a,b)=> (a.category||'').localeCompare(b.category||'') || a.title.localeCompare(b.title));

      const strip = $("#topicStrip"); 
      strip.innerHTML = '';
      
      topics.forEach(t => {
        const btn = document.createElement('button');
        btn.className = 'topic-btn chip'; 
        btn.textContent = t.title; 
        btn.dataset.id = t.id; 
        btn.dataset.category = t.category;
        btn.addEventListener('click', ()=> showTopic(t.id, true));
        strip.appendChild(btn);
      });

      // Category filter
      const cats = Array.from(new Set(topics.map(t=>t.category))).sort();
      const catSel = $("#categoryFilter");
      catSel.innerHTML = '<option value="">All categories</option>' + cats.map(c=>`<option value="${c}">${c}</option>`).join('');
      catSel.addEventListener('change', () => applyFilters());

      // Sidebar (subtopics for current category)
      buildSidebar();
    }

    function buildSidebar(currentCategory){
      const side = $("#sideList");
      const topics = $$(".topic").map(a => ({ id:a.id, title:a.dataset.title, category:a.dataset.category }));
      const cat = currentCategory || $('#categoryFilter').value || (localStorage.getItem('lastCat')||'');
      const filtered = topics.filter(t => !cat || t.category === cat);
      $('#sideTitle').textContent = cat ? `${cat} — Subtopics` : 'All Subtopics';
      side.innerHTML = '';
      
      filtered.forEach(t => {
        const a = document.createElement('a'); 
        a.href = '#'; 
        a.textContent = t.title; 
        a.className='sidelink'; 
        a.addEventListener('click', (e)=>{
          e.preventDefault(); 
          showTopic(t.id, true);
          // Close mobile sidebar after selection
          if (isMobileView()) {
            const sidebarContent = $('#sidebarContent');
            const sidebarToggle = $('#sidebarToggle');
            sidebarContent.classList.remove('active');
            sidebarToggle.classList.remove('active');
          }
        });
        side.appendChild(a);
      });
    }

    function applyFilters(){
      const term = $('#search').value.trim().toLowerCase();
      const cat = $('#categoryFilter').value;
      
      $$('#topicStrip .topic-btn').forEach(b => {
        const matchTerm = !term || b.textContent.toLowerCase().includes(term);
        const matchCat = !cat || b.dataset.category === cat;
        b.classList.toggle('hidden', !(matchTerm && matchCat));
      });
      
      buildSidebar(cat);
      localStorage.setItem('lastCat', cat||'');
      
      // Close mobile menu after applying filters
      if (isMobileView()) {
        $('#filtersMenu').classList.add('hidden');
      }
    }

    // Show a single topic; optionally scroll to top
    function showTopic(id, remember){
      $$('.topic').forEach(t => t.classList.add('hidden'));
      const el = document.getElementById(id); 
      if(!el) return;
      
      el.classList.remove('hidden');
      $$('#sideList .sidelink').forEach(a=> a.classList.toggle('active', a.textContent === el.dataset.title));
      $$('#topicStrip .topic-btn').forEach(b=> b.classList.toggle('chip-active', b.dataset.id===id));
      
      if(remember){ 
        localStorage.setItem('lastTopic', id); 
      }
      
      // Smooth scroll to top with offset for fixed header
      const headerHeight = $('header').offsetHeight || 100;
      window.scrollTo({ 
        top: isMobileView() ? headerHeight : 0, 
        behavior: 'smooth' 
      });
    }

    // Print current topic
    $('#printBtn').addEventListener('click', ()=>{
      window.print();
    });

    // Expand/Collapse controls
    $('#expandAllBtn').addEventListener('click', ()=>{
      $$('.topic').forEach(t => t.classList.remove('hidden'));
      // Close mobile menu
      if (isMobileView()) {
        $('#filtersMenu').classList.add('hidden');
      }
    });
    
    $('#collapseAllBtn').addEventListener('click', ()=>{
      const id = localStorage.getItem('lastTopic') || 'fundamentals';
      showTopic(id, false);
      // Close mobile menu
      if (isMobileView()) {
        $('#filtersMenu').classList.add('hidden');
      }
    });

    // Enhanced search handlers
    $('#search').addEventListener('input', () => {
      // Real-time search on desktop, debounced on mobile
      if (!isMobileView()) {
        applyFilters();
      }
    });
    
    $('#search').addEventListener('keypress', (e)=>{ 
      if(e.key==='Enter'){ 
        e.preventDefault();
        applyFilters(); 
        const firstVisible=$$('#topicStrip .topic-btn:not(.hidden)')[0]; 
        if(firstVisible){ 
          showTopic(firstVisible.dataset.id, true); 
        }
        // Blur search on mobile to hide keyboard
        if (isMobileView()) {
          $('#search').blur();
        }
      } 
    });
    
    // Focus search with '/' key (desktop only)
    document.addEventListener('keydown', (e)=>{ 
      if(e.key==='/' && document.activeElement.tagName!=='INPUT' && !isMobileView()){ 
        e.preventDefault(); 
        $('#search').focus(); 
      }
    });
    
    // Touch-friendly interactions
    function initTouchSupport() {
      // Add touch feedback to buttons
      $$('button, .chip, .sidelink').forEach(el => {
        el.addEventListener('touchstart', () => {
          el.style.transform = 'scale(0.95)';
        });
        
        el.addEventListener('touchend', () => {
          setTimeout(() => {
            el.style.transform = '';
          }, 150);
        });
      });
      
      // Prevent zoom on double-tap for iOS
      document.addEventListener('touchend', (e) => {
        const now = new Date().getTime();
        if (now - (window.lastTouchEnd || 0) <= 300) {
          e.preventDefault();
        }
        window.lastTouchEnd = now;
      }, false);
    }
    
    // Performance optimization: Intersection Observer for topic visibility
    function initIntersectionObserver() {
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              // Lazy load any heavy content if needed
              entry.target.classList.add('visible');
            }
          });
        }, { threshold: 0.1 });
        
        $$('.topic').forEach(topic => observer.observe(topic));
      }
    }
    
    // Initialize everything
    function init() {
      attachCopy();
      buildNav();
      initMobileMenu();
      initMobileSidebar();
      handleResponsiveFilters();
      initTouchSupport();
      initIntersectionObserver();
      applyFilters();
      
      const last = localStorage.getItem('lastTopic') || 'fundamentals';
      showTopic(last, false);
      
      // Add loaded class to body for CSS transitions
      document.body.classList.add('loaded');
    }
    
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    
    // Handle orientation changes on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        // Recalculate layout after orientation change
        handleResponsiveFilters();
      }, 100);
    });
  </script>
</body>
</html>
